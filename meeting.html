<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>æœƒè­°å®¤ (å¤šäºº) - å³æ™‚èªéŸ³è½‰æ–‡å­—</title>
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/meeting.css">

    <!-- Supabase SDK -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <!-- PeerJS SDK -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        .audio-unlock-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .audio-unlock-content {
            text-align: center;
            color: #1f2937;
            padding: 48px;
            border-radius: 32px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
        }

        .audio-unlock-content h2 {
            margin: 20px 0 10px;
            font-size: 24px;
            background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .audio-unlock-content p {
            margin-bottom: 24px;
            color: #4b5563;
        }
    </style>
</head>

<body>
    <div class="meeting-container">
        <!-- é ‚éƒ¨å·¥å…·åˆ— -->
        <header class="meeting-header">
            <div class="header-left">
                <h1><svg style="width:22px;height:22px;vertical-align:middle;margin-right:6px;" viewBox="0 0 24 24"
                        fill="none" stroke="#805ad5" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                        <line x1="12" y1="19" x2="12" y2="23" />
                        <line x1="8" y1="23" x2="16" y2="23" />
                    </svg>æœƒè­°å®¤ (å¤šäººæ¨¡å¼)</h1>
                <span id="participantCount" class="participant-count">è¼‰å…¥ä¸­...</span>
            </div>
            <div class="header-right">
                <select id="languageSelect" class="language-select">
                    <option value="zh-TW">ä¸­æ–‡</option>
                    <option value="en-US">English</option>
                </select>
                <button id="speakerBtn" class="btn-secondary" title="å–‡å­"><svg style="width:18px;height:18px;"
                        viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" />
                    </svg></button>
                <button id="startBtn" class="btn-primary">é–‹å§‹éŒ„éŸ³</button>
                <button id="leaveBtn" class="btn-danger">é›¢é–‹æœƒè­°</button>
            </div>
        </header>

        <!-- ä¸»è¦å…§å®¹å€ -->
        <main class="meeting-main">
            <!-- åƒèˆ‡è€…ç¶²æ ¼ -->
            <div id="participantGrid" class="participant-grid">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </main>

        <!-- éŸ³è¨Šè§£é–æç¤ºï¼ˆè§£æ±ºç€è¦½å™¨ autoplay æ”¿ç­–ï¼‰ -->
        <div id="audioUnlockOverlay" class="audio-unlock-overlay" style="display: none;">
            <div class="audio-unlock-content">
                <svg style="width:48px;height:48px;" viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2">
                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" />
                </svg>
                <h2>é»æ“Šå•Ÿç”¨èªéŸ³é€šè©±</h2>
                <p>ç€è¦½å™¨éœ€è¦æ‚¨çš„äº’å‹•æ‰èƒ½æ’­æ”¾éŸ³è¨Š</p>
                <button id="unlockAudioBtn" class="btn-primary" style="font-size: 18px; padding: 12px 32px;">
                    é»æ“Šå•Ÿç”¨
                </button>
            </div>
        </div>

        <!-- å­—å¹•æ¢ - å›ºå®šåœ¨åº•éƒ¨ -->
        <div class="caption-container" id="captionContainer">
            <div class="caption-header">
                <span>å³æ™‚å­—å¹•èˆ‡æ•¸æ“š</span>
                <button id="toggleExpand" class="btn-toggle">å±•é–‹å®Œæ•´è¦–åœ–</button>
            </div>
            <div class="caption-bar" id="captionBar">
                <!-- å­—å¹•é …ç›®å°‡æœƒåœ¨é€™è£¡å‹•æ…‹æ–°å¢ -->
            </div>
            <div id="captionFull" class="caption-full">
                <!-- å®Œæ•´å°è©±é¡¯ç¤º -->
            </div>
        </div>
    </div>

    <script>
        console.log('=== å¤šäººæœƒè­°å®¤åˆå§‹åŒ– ===');

        // å¾ URL å–å¾—æˆ¿é–“ ID
        const urlParams = new URLSearchParams(window.location.search);
        const MEETING_ID = urlParams.get('room') || 'main-room';
        console.log('æœƒè­°å®¤ ID:', MEETING_ID);

        // åˆå§‹åŒ– Supabase
        const { createClient } = supabase;
        const supabaseClient = createClient(
            'https://inzqsdelrwxxlbcumaiw.supabase.co',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImluenFzZGVscnd4eGxiY3VtYWl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3MTQzMjksImV4cCI6MjA4MzI5MDMyOX0.XBrMbxu_vcNQb55v6OZNoB-Mm1w-A2OtJk1AAgofjg0'
        );
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImluenFzZGVscnd4eGxiY3VtYWl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3MTQzMjksImV4cCI6MjA4MzI5MDMyOX0.XBrMbxu_vcNQb55v6OZNoB-Mm1w-A2OtJk1AAgofjg0';



        let currentUser = null;
        let recognition = null;
        let isRecording = false;
        let isSpeaking = false;
        let audioLevel = 0; // ğŸŸ¢ æ–°å¢ï¼šéŸ³é‡ç­‰ç´š
        let speakingActivityDetected = false; // ğŸŸ¢ æ–°å¢ï¼šæœ¬æ¬¡é€±æœŸæ˜¯å¦æœ‰æ•æ‰åˆ°äººè²

        // --- èªéŸ³è½‰éŒ„å…¨åŸŸè®Šæ•¸ ---
        let audioContext = null;
        let audioStream = null;
        let processor = null;
        let socket = null;
        // ----------------------

        let participants = new Map();
        let participantsChannel = null;
        let captionsChannel = null;
        let roomWordBoost = []; // Word Boost é—œéµè©
        let isOwner = false; // æ˜¯å¦ç‚ºæˆ¿ä¸» (å‰µç«‹è€…)
        let sessionStartTime = new Date().toISOString(); // æœ¬æ¬¡ Session èµ·é»æ™‚é–“


        // æª¢æŸ¥æˆ¿é–“å­˜å–æ¬Šé™
        async function checkRoomAccess() {
            // å¦‚æœæ˜¯é è¨­æˆ¿é–“ï¼Œä¸æª¢æŸ¥æ¬Šé™
            if (MEETING_ID === 'main-room') {
                return true;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('room_access')
                    .select('*')
                    .eq('room_id', MEETING_ID)
                    .eq('email', currentUser.email)
                    .single();

                if (error || !data) {
                    alert('æ‚¨æ²’æœ‰æ¬Šé™é€²å…¥æ­¤æœƒè­°å®¤');
                    window.location.href = 'index.html';
                    return false;
                }

                console.log('âœ… æ¬Šé™é©—è­‰é€šé');
                return true;

            } catch (error) {
                console.error('æ¬Šé™æª¢æŸ¥å¤±æ•—:', error);
                alert('æ¬Šé™æª¢æŸ¥å¤±æ•—');
                window.location.href = 'index.html';
                return false;
            }
        }

        // ç«‹å³æª¢æŸ¥ç™»å…¥ç‹€æ…‹ï¼ˆåœ¨é é¢è¼‰å…¥æ™‚ï¼‰
        (async function checkAuthImmediately() {
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (!session) {
                console.log('âŒ æœªç™»å…¥ï¼Œè·³è½‰åˆ°é¦–é ');
                alert('è«‹å…ˆç™»å…¥');
                window.location.href = 'index.html';
                return;
            }
            console.log('âœ… å·²ç™»å…¥ï¼Œç¹¼çºŒè¼‰å…¥æœƒè­°å®¤');
        })();

        // æª¢æŸ¥ç™»å…¥ç‹€æ…‹ä¸¦åŠ å…¥æœƒè­°
        supabaseClient.auth.getSession().then(async ({ data: { session } }) => {
            if (!session) {
                window.location.href = 'index.html';
                return;
            }

            currentUser = session.user;
            console.log('âœ… ä½¿ç”¨è€…å·²ç™»å…¥', currentUser.email);

            // 1. åˆå§‹åŒ–æˆ¿é–“é »é“ (åŒ…å« Presence)
            initRoomChannel();

            // 2. è¨‚é–±å¿…è¦é »é“
            subscribeToCaptions();

            // 3. åˆ¤å®šæ¬Šé™ & Session
            await handleOwnerSession();

            // 4. å…¶ä»–åˆå§‹åŒ–
            await loadRoomWordBoost();
            // initSpeechRecognition(); // âŒ å¾¹åº•é—œé–‰ç€è¦½å™¨å…§å»º STTï¼Œé˜²æ­¢äº‚è·³æ•¸å­—
        });

        // åˆå§‹åŒ–æˆ¿é–“é »é“èˆ‡ Presence
        function initRoomChannel() {
            const channel = supabaseClient.channel(`room-${MEETING_ID}`, {
                config: {
                    presence: {
                        key: currentUser.id,
                    },
                },
            });

            channel
                .on('presence', { event: 'sync' }, () => {
                    const newState = channel.presenceState();
                    console.log('ğŸ‘¥ ç›®å‰åœ¨ç·šåå–®:', newState);
                    handlePresenceSync(newState);
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    console.log('ğŸ‘‹ æœ‰äººé€²ä¾†äº†:', newPresences);
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    console.log('ğŸƒ æœ‰äººé›¢é–‹äº†:', leftPresences);
                    // ğŸ”´ ä¿®æ­£ï¼šä¸å†æ ¹æ“š Presence é›¢é–‹äº‹ä»¶è¸¢äººï¼Œä»¥æ”¯æ´é‡æ–°æ•´ç†
                })
                .on('postgres_changes', {
                    event: 'UPDATE',
                    schema: 'public',
                    table: 'rooms',
                    filter: `room_id=eq.${MEETING_ID}`
                }, (payload) => {
                    console.log('ğŸ  æˆ¿é–“ç‹€æ…‹æ›´æ–°:', payload.new);
                    // ğŸ”´ é—œéµï¼šåªæœ‰ç•¶ is_active è¢«æ˜ç¢ºè¨­ç‚º false æ™‚ï¼Œæ‰æ¸…å ´
                    if (payload.new.is_active === false) {
                        console.warn('ğŸš¨ æˆ¿ä¸»å·²é—œé–‰æœƒè­°ï¼ŒåŸ·è¡Œé€€å ´ç¨‹åº');
                        triggerHostLeave();
                    }
                })
                .on('broadcast', { event: 'new_session' }, (payload) => {
                    console.log('ğŸ“¡ æ”¶åˆ°æˆ¿ä¸» Session æŒ‡ä»¤:', payload);
                    if (payload.sessionStartTime) {
                        sessionStartTime = payload.sessionStartTime;
                        refreshLiveView();
                    }
                })
                .subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        // è¿½è¹¤è‡ªå·± (ç¨å¾®å»¶é²ä¸€ä¸‹ï¼Œç­‰ handleOwnerSession ç¢ºå®š isOwner)
                        setTimeout(async () => {
                            await channel.track({
                                user_id: currentUser.id,
                                user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                                photo_url: currentUser.user_metadata?.avatar_url,
                                email: currentUser.email,
                                is_host: isOwner,
                                session_start_time: isOwner ? sessionStartTime : null,
                                online_at: new Date().toISOString(),
                            });
                        }, 500);
                    }
                });

            window.roomChannel = channel;
        }

        function handlePresenceSync(state) {
            // å¾ Presence ç‹€æ…‹ä¸­æ‰¾å°‹æˆ¿ä¸»ï¼Œä¸¦åŒæ­¥å…¶ Session èµ·é»
            // ä¿®æ­£ï¼šä¸ä½¿ç”¨ flat()ï¼Œä¿ç•™ key (å³ user_id) ä½œç‚ºè­˜åˆ¥ä¾æ“šï¼Œè§£æ±ºé‡è¤‡æˆ–éºå¤±å•é¡Œ

            participants.clear();
            let hostFound = null;

            for (const userId in state) {
                const presences = state[userId];
                if (presences && presences.length > 0) {
                    const u = presences[0]; // åŒä¸€å¸³æˆ¶å¤šå€‹åˆ†é ï¼Œä»¥ç¬¬ä¸€å€‹ç‚ºæº–

                    const pData = {
                        user_id: userId,
                        user_name: u.user_name || 'åŒ¿å',
                        photo_url: u.photo_url || null,
                        is_speaking: u.is_speaking || false,
                        is_host: u.is_host || false,
                        session_start_time: u.session_start_time || null
                    };

                    participants.set(userId, pData);

                    if (u.is_host) hostFound = pData;
                }
            }

            // 1. åŒæ­¥æˆ¿ä¸»ç‹€æ…‹èˆ‡ Session èµ·é»
            if (hostFound && hostFound.session_start_time && !isOwner) {
                if (sessionStartTime !== hostFound.session_start_time) {
                    console.log('ğŸ”„ åŒæ­¥æˆ¿ä¸» Session èµ·é»:', hostFound.session_start_time);
                    sessionStartTime = hostFound.session_start_time;
                    refreshLiveView();
                }
            }

            // 2. ğŸŸ¢ å³æ™‚åˆ·æ–°ç¶²æ ¼èˆ‡è¨ˆæ•¸ (å–®ä¸€ä¾†æºåŸå‰‡)
            updateParticipantGrid();
            updateParticipantCount();

            // 3. æª¢æŸ¥ä¸»æŒäººæ˜¯å¦åœ¨ç·š (å·²ç”± DB ç‹€æ…‹å–ä»£å¼•ç™¼é€€å ´)
            // checkHostStatus();
        }

        // å¼·åˆ¶é‡æ–°è¼‰å…¥ç•¶å‰ Session è¦–åœ–
        function refreshLiveView() {
            console.log('ğŸ”„ é‡æ–°æ•´ç† Live è¦–åœ–...');
            const captionBar = document.getElementById('captionBar');
            const captionFull = document.getElementById('captionFull');
            if (captionBar) captionBar.innerHTML = '';
            if (captionFull) captionFull.innerHTML = '';
            loadRecentHistory();
        }

        function checkHostLeave(leftUsers) {
            // ğŸ”´ å·²ç”± DB ç‹€æ…‹ç›£è½å–ä»£ï¼Œè§£æ±ºé‡æ•´èª¤è¸¢å•é¡Œ
            /*
            if (isOwner) return;
            const hostLeft = leftUsers.some(u => u.is_host);
            if (hostLeft) {
                console.log('âš ï¸ æˆ¿ä¸»å·²é›¢é–‹');
                triggerHostLeave();
            }
            */
        }

        // å®šæœŸæª¢æŸ¥ Presence (åƒ…ç”¨æ–¼åå–®é¡¯ç¤ºï¼Œå·²ç§»é™¤è¸¢äººé‚è¼¯)
        setInterval(() => {
            if (!isOwner && window.roomChannel) {
                /*
                const state = window.roomChannel.presenceState();
                const users = Object.values(state).flat();
                const hostOnline = users.some(u => u.is_host);
                if (!hostOnline && users.length > 0) {
                    // triggerHostLeave(); 
                }
                */
            }
        }, 5000);

        function loadParticipantsFromPresence(users) {
            // æ›´æ–°ç•«é¢çš„åƒèˆ‡è€…æ¸…å–® (æ›¿ä»£éƒ¨åˆ†è³‡æ–™åº«è² æ“”)
            const countEl = document.getElementById('participantCount');
            if (countEl) countEl.textContent = `${users.length} äººåœ¨ç·š`;
        }

        function subscribeToSessionBroadcast() {
            // å·²ä½µå…¥ initRoomChannel
        }

        // è™•ç†æˆ¿ä¸» Sessionï¼šå¦‚æœæ˜¯æˆ¿ä¸»ï¼Œå‰‡é‡ç½® Session èµ·é»ï¼›å¦‚æœä¸æ˜¯ï¼Œå‰‡è¼‰å…¥æ­·å²
        async function handleOwnerSession() {
            try {
                const hasAccess = await checkRoomAccess();
                if (!hasAccess) return;

                // ğŸ”´ é—œéµæ”¹å‹•ï¼šå¾ rooms è¡¨æŸ¥è©¢çœŸæ­£çš„å‰µç«‹è€… (created_by)
                const { data: roomData, error: roomError } = await supabaseClient
                    .from('rooms')
                    .select('created_by')
                    .eq('room_id', MEETING_ID)
                    .single();

                if (roomError) {
                    // è‹¥ rooms è¡¨æŸ¥ä¸åˆ° (å¯èƒ½æ˜¯èˆŠæ ¼å¼æˆ– main-room)ï¼Œå›é€€åˆ° room_access åˆ¤å®šæˆ–å¿½ç•¥
                    console.warn('ç„¡æ³•å¾ rooms è¡¨ç¢ºèªæˆ¿ä¸»èº«åˆ†ï¼Œä½¿ç”¨å­˜å–åˆ—è¡¨åˆ¤å®š');
                    const { data: accessData } = await supabaseClient
                        .from('room_access')
                        .select('email')
                        .eq('room_id', MEETING_ID);
                    const ownerEmails = accessData ? accessData.map(item => item.email) : [];
                    isOwner = ownerEmails.includes(currentUser.email);
                } else {
                    // ä»¥ created_by UID ç‚ºæº–
                    isOwner = (roomData.created_by === currentUser.id);
                }

                if (isOwner) {
                    console.log('ğŸ‘‘ æ‚¨æ˜¯æ­¤æœƒè­°å®¤çš„çœŸæ­£æˆ¿ä¸»ï¼Œæ­£åœ¨å˜—è©¦æ¢å¾©æˆ–é‡ç½® Session...');

                    // ğŸŸ¢ ä¿®æ­£ï¼šå„ªå…ˆå¾ rooms è¡¨çœ‹æœ‰æ²’æœ‰æ—¢å­˜çš„ session_start_time (é˜²æ­¢é‡æ–°æ•´ç†éºå¤±ç´€éŒ„)
                    const { data: currentRoom } = await supabaseClient
                        .from('rooms')
                        .select('session_start_time')
                        .eq('room_id', MEETING_ID)
                        .single();

                    if (currentRoom && currentRoom.session_start_time) {
                        console.log('ğŸ“œ æ¢å¾©æ—¢å­˜ Session:', currentRoom.session_start_time);
                        sessionStartTime = currentRoom.session_start_time;
                    } else {
                        console.log('ğŸ†• å‰µå»ºå…¨æ–° Session');
                        sessionStartTime = new Date().toISOString().replace(/[:.]/g, '-');
                    }

                    // ğŸ”´ ç¢ºä¿æˆ¿é–“è™•æ–¼ Active ç‹€æ…‹
                    await supabaseClient
                        .from('rooms')
                        .update({
                            session_start_time: sessionStartTime,
                            is_active: true
                        })
                        .eq('room_id', MEETING_ID);

                    broadcastSessionStart(sessionStartTime);
                } else {
                    isOwner = false;
                    console.log('ğŸ‘¥ æ‚¨æ˜¯åƒèˆ‡è€…ï¼Œæ­£åœ¨æ¨å° Session èµ·é»...');
                    await deriveSessionFromHost();
                }

                // æ›´æ–°è‡ªå·±çš„ Presence æ¨™ç±¤ (ç¢ºä¿åŒ…å«é ­åƒ)
                if (window.roomChannel) {
                    await window.roomChannel.track({
                        user_id: currentUser.id,
                        user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                        photo_url: currentUser.user_metadata?.avatar_url,
                        email: currentUser.email,
                        is_host: isOwner,
                        session_start_time: isOwner ? sessionStartTime : null,
                        online_at: new Date().toISOString(),
                    });
                }

                await joinMeeting();
                // await loadParticipants(); // ğŸŸ¡ å·²æ”¹ç”¨ Presence é©…å‹•ï¼Œä¸åœ¨æ­¤è¼‰å…¥ DB åå–®ï¼Œé˜²æ­¢è³‡æ–™è¦†è“‹
                await loadRecentHistory();
            } catch (err) {
                console.warn('Session åˆå§‹åŒ–ç•°å¸¸', err);
                await joinMeeting();
                await loadRecentHistory();
            }
        }

        // å¾åœ¨ç·šæˆ¿ä¸»æ¨å°èµ·é» (å¦‚æœæœ‰çš„è©±)
        async function deriveSessionFromHost() {
            try {
                // æŠ“å–åœ¨ç·šçš„æ‰€æœ‰åƒèˆ‡è€…
                const { data } = await supabaseClient
                    .from('participants')
                    .select('user_name, created_at')
                    .eq('meeting_id', MEETING_ID)
                    .eq('status', 'online');

                if (data && data.length > 0) {
                    // ç›®å‰ç°¡å–®åŒ–ï¼šä»¥åˆ—è¡¨ä¸­æœ€æ—©åŠ å…¥çš„äººçš„æ™‚é–“ä½œç‚ºèµ·é» (é€šå¸¸æ˜¯æˆ¿ä¸»æˆ– Session é–‹å§‹è€…)
                    const earliest = data.reduce((min, p) =>
                        new Date(p.created_at) < new Date(min) ? p.created_at : min, data[0].created_at);
                    sessionStartTime = earliest;
                }
            } catch (e) {
                console.warn('ç„¡æ³•æ¨å° Session èµ·é»');
            }
        }

        function broadcastSessionStart(time) {
            if (window.sessionChannel) {
                window.sessionChannel.send({
                    type: 'broadcast',
                    event: 'new_session',
                    sessionStartTime: time
                });
            }
        }

        // ç§»é™¤å ±éŒ¯çš„è³‡æ–™åº«æ›´æ–°å‡½æ•¸
        // async function updateRoomResetTime... (ä¸å†éœ€è¦)

        // æ¸…ç©ºè¦–åœ–æŒ‡ä»¤è½‰ç™¼ (ä¸å†ç‰©ç†åˆªé™¤)
        async function clearMeetingHistory() {
            console.log('ğŸš« ç‰©ç†åˆªé™¤åŠŸèƒ½å·²åœç”¨ï¼Œç´€éŒ„ä¿å­˜åœ¨è³‡æ–™åº«ä¸­');
        }

        // è¼‰å…¥ç•¶å‰ Session çš„å°è©±ç´€éŒ„
        async function loadRecentHistory() {
            if (!sessionStartTime) {
                console.warn('âš ï¸ å°šæœªå–å¾— Session èµ·é»ï¼Œè·³éè¼‰å…¥æ­·å²');
                return;
            }
            console.log('ğŸ“œ æ­£åœ¨è¼‰å…¥ Session èµ·é»ä»¥å¾Œçš„ç´€éŒ„...', sessionStartTime);
            try {
                const sessionTaggedId = MEETING_ID + ':::' + sessionStartTime;
                const { data, error } = await supabaseClient
                    .from('captions')
                    .select('*')
                    .eq('meeting_id', sessionTaggedId) // ğŸŸ¢ åªè¼‰å…¥æœ¬æ¬¡ Session çš„ç´€éŒ„
                    .order('created_at', { ascending: true });

                if (error) throw error;

                // æ¸…ç©ºèˆŠè¦–åœ–é˜²æ­¢é‡è¤‡è¼‰å…¥
                const captionBar = document.getElementById('captionBar');
                const captionFull = document.getElementById('captionFull');
                if (captionBar) captionBar.innerHTML = '';
                if (captionFull) captionFull.innerHTML = '';

                if (data && data.length > 0) {
                    console.log(`âœ… å·²è¼‰å…¥ ${data.length} æ¢ Live å°è©±`);
                    data.forEach(caption => {
                        displayRemoteCaption(caption, false);
                    });
                }
            } catch (err) {
                console.error('è¼‰å…¥ç´€éŒ„å¤±æ•—:', err);
            }
        }

        // åŠ å…¥æœƒè­°å®¤
        async function joinMeeting() {
            try {
                const { error } = await supabaseClient
                    .from('participants')
                    .upsert({
                        meeting_id: MEETING_ID,
                        user_id: currentUser.id,
                        user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                        photo_url: currentUser.user_metadata?.avatar_url,
                        status: 'online',
                        is_speaking: false
                    }, {
                        onConflict: 'meeting_id,user_id'
                    });

                if (error) throw error;
                console.log('âœ… å·²åŠ å…¥æœƒè­°å®¤');
            } catch (error) {
                console.error('åŠ å…¥æœƒè­°å¤±æ•—:', error);
            }
        }

        /* å·²ç¶“æ”¹ç”¨ Presence é©…å‹• UIï¼Œä¸éœ€è¦å†ç›£è½è³‡æ–™åº«è®ŠåŒ–é˜²æ­¢ Overwrite
        participantsChannel = supabaseClient
            .channel('participants-changes')
            // ...
        */

        // æª¢æŸ¥ä¸»æŒäººæ˜¯å¦åœ¨ç·š (åŸºæ–¼ Presence çš„æœ€çµ‚æ–¹æ¡ˆ)
        function checkHostStatus() {
            if (isOwner) return; // æˆ‘å°±æ˜¯æˆ¿ä¸»ï¼Œä¸ç”¨æª¢æŸ¥

            if (!window.roomChannel) return;

            const state = window.roomChannel.presenceState();
            const users = Object.values(state).flat();
            const hostOnline = users.some(u => u.is_host);

            console.log('ğŸ” æª¢æŸ¥æˆ¿ä¸»ç‹€æ…‹:', hostOnline ? 'åœ¨ç·š' : 'ä¸‹ç·š');

            if (!hostOnline) {
                // ç‚ºäº†é˜²æ­¢ç¬æ–·èª¤åˆ¤ï¼Œæˆ‘å€‘åœ¨ 3 ç§’å¾Œå†ç¢ºèªä¸€æ¬¡
                setTimeout(() => {
                    const latestState = window.roomChannel.presenceState();
                    const latestUsers = Object.values(latestState).flat();
                    const stillOffline = !latestUsers.some(u => u.is_host);
                    if (stillOffline) {
                        console.warn('ğŸš¨ æˆ¿ä¸»ç¢ºå®šä¸‹ç·šï¼Œè§¸ç™¼æ¸…å ´');
                        triggerHostLeave();
                    }
                }, 3000);
            }
        }

        async function triggerHostLeave() {
            console.log('ğŸš¨ åŸ·è¡Œé€€å ´ç¨‹åº...');
            await leaveMeeting(); // ç¢ºä¿å…ˆæ–·é–‹æ‰€æœ‰é€£ç·šèˆ‡ Presence
            setTimeout(() => {
                alert('æœƒè­°ä¸»æŒäººå·²é›¢é–‹ï¼Œæœƒè­°çµæŸã€‚');
                window.location.href = 'index.html';
            }, 500);
        }

        // è¨‚é–±å­—å¹•
        function subscribeToCaptions() {
            console.log('ğŸ”” è¨­å®šå­—å¹•è¨‚é–±ï¼Œæœƒè­°å®¤:', MEETING_ID);
            captionsChannel = supabaseClient
                .channel('captions-changes')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'captions'
                }, (payload) => {
                    console.log('ğŸ“ æ”¶åˆ°å­—å¹•äº‹ä»¶:', payload.new);
                    // åªé¡¯ç¤ºç•¶å‰æœƒè­°å®¤ç•¶å‰ Session çš„å­—å¹•ï¼Œä¸”å¿½ç•¥è‡ªå·±çš„ï¼ˆé¿å…é‡è¤‡é¡¯ç¤ºï¼‰
                    const sessionTaggedId = MEETING_ID + ':::' + sessionStartTime;
                    if (payload.new.meeting_id === sessionTaggedId &&
                        payload.new.user_id !== currentUser?.id) {
                        displayRemoteCaption(payload.new);
                    }
                })
                .subscribe((status) => {
                    console.log('ğŸ”Œ å­—å¹•è¨‚é–±ç‹€æ…‹:', status);
                });
        }

        // å·²ç§»é™¤èˆŠæœ‰çš„å…¨å±€ showDataSnapshot å‡½æ•¸
        // å·²ç§»é™¤èˆŠæœ‰çš„å…¨å±€ showDataSnapshot å‡½æ•¸
        function getNumericalTags(text) {
            if (!text) return [];

            // è™•ç† Deepgram å¸¸è¦‹çš„ä¸­æ–‡æ ¼å¼åŒ–æ¨™é»ï¼š
            // ã€Œã€‚ã€æœ‰æ™‚æœƒè¢«èª¤ç”¨ç‚ºå°æ•¸é»ï¼Œã€Œã€ã€æœ‰æ™‚æœƒè¢«èª¤ç”¨ç‚ºåƒåˆ†ä½
            const cleanedText = text.replace(/(\d)ã€‚(\d)/g, '$1.$2').replace(/(\d)ã€(\d)/g, '$1,$2');

            // åŒ¹é…æ•¸å­—ä»¥åŠå¯èƒ½å‰å¾Œè·Ÿéš¨çš„å–®ä½
            const units = "ç¾é‡‘|å…ƒ|æ¬¡|å€‹|%|å°å¹£|HKD|USD|è‹±éŠ|æ­å…ƒ|åˆ†|é»";
            const regex = new RegExp(`\\d+[.]\\d+\\s*(?:${units})?|(?:[$Â¥â‚¬])?\\d+(?:[,]\\d+)*\\s*(?:${units})|\\d{3,}`, "gi");

            let matches = cleanedText.match(regex) || [];
            const results = [...new Set(matches.map(m => m.trim()))];

            return results.filter(m => {
                const hasUnit = new RegExp(`[$Â¥â‚¬%${units}]`).test(m);
                const hasDot = /[.]/.test(m);
                const digits = m.replace(/[^0-9]/g, '');
                return hasDot || hasUnit || (digits.length >= 3);
            });
        }

        // --- ç›¸å®¹æ€§è£œä¸ï¼šé¿å…èˆŠç¨‹å¼ç¢¼å‘¼å« addCaption å°è‡´å´©æ½° ---
        function addCaption(speaker, text, isFinal = true) {
            console.log('ğŸ”„ å‘¼å«ç›¸å®¹å±¤ addCaption:', speaker, text);
            if (isFinal) {
                const tags = getNumericalTags(text);
                showLocalCaption(text, tags);
                saveCaption(text, true);
            } else {
                showInterimCaption(text);
            }
        }

        // è¼‰å…¥åƒèˆ‡è€…åˆ—è¡¨ (æ­·å²ç”¨é€”ï¼Œç¾åœ¨ UI ç”± Presence é©…å‹•)
        async function loadParticipants() {
            /* ğŸŸ¡ åœç”¨è³‡æ–™åº«é©…å‹• UIï¼Œæ”¹ç”± handlePresenceSync æ¥ç®¡
            try {
                const { data, error } = await supabaseClient
                    .from('participants')
                    .select('*')
                    .eq('meeting_id', MEETING_ID)
                    .eq('status', 'online');

                if (error) throw error;
                // ...
            } catch (error) {
                console.error('è¼‰å…¥åƒèˆ‡è€…å¤±æ•—:', error);
            }
            */
        }

        // è¼‰å…¥ Word Boost é—œéµè©
        async function loadRoomWordBoost() {
            // é è¨­æˆ¿é–“ä¸è¼‰å…¥
            if (MEETING_ID === 'main-room') return;

            try {
                const { data: room, error } = await supabaseClient
                    .from('rooms')
                    .select('word_boost')
                    .eq('room_id', MEETING_ID)
                    .single();

                if (error) throw error;

                if (room && room.word_boost && room.word_boost.length > 0) {
                    roomWordBoost = room.word_boost;
                    console.log('ğŸ¯ å·²è¼‰å…¥ Word Boost é—œéµè©:', roomWordBoost.length, 'å€‹');
                }
            } catch (error) {
                console.error('è¼‰å…¥ Word Boost å¤±æ•—:', error);
            }
        }

        // æ›´æ–°åƒèˆ‡è€…ç¶²æ ¼
        function updateParticipantGrid() {
            const grid = document.getElementById('participantGrid');
            grid.innerHTML = '';

            // è¨­å®š data-count å±¬æ€§ä¾› CSS ä½¿ç”¨
            grid.setAttribute('data-count', participants.size);

            participants.forEach((participant, userId) => {
                const isMe = userId === currentUser.id;
                const card = document.createElement('div');
                card.className = 'participant-card';
                card.id = `participant-${userId}`;

                if (participant.is_speaking) {
                    card.classList.add('speaking');
                }

                card.innerHTML = `
                    <div class="participant-photo">
                        ${participant.photo_url
                        ? `<img src="${participant.photo_url}" alt="${participant.user_name}">`
                        : `<div class="photo-placeholder">${participant.user_name.charAt(0).toUpperCase()}</div>`
                    }
                        <div class="participant-name">${participant.user_name}${isMe ? ' (æˆ‘)' : ''}</div>
                    </div>
                `;

                grid.appendChild(card);
            });
        }

        // æ›´æ–°åƒèˆ‡è€…è¨ˆæ•¸
        function updateParticipantCount() {
            document.getElementById('participantCount').textContent = `${participants.size} äºº`;
        }





        // API è¨­å®š
        const ASSEMBLYAI_URL = 'https://inzqsdelrwxxlbcumaiw.supabase.co/functions/v1/assemblyai-speech';
        const GROQ_URL = 'https://inzqsdelrwxxlbcumaiw.supabase.co/functions/v1/groq-speech';
        const GEMINI_PUNCTUATION_URL = 'https://inzqsdelrwxxlbcumaiw.supabase.co/functions/v1/gemini-punctuation';

        let mediaRecorder = null;
        let recordingInterval = null;
        let audioChunks = [];

        // é–‹å§‹ Groq (Whisper) è½‰éŒ„æ¨¡å¼
        async function startAssemblyAIBatch() {
            try {
                // å„ªå…ˆä½¿ç”¨ç¾æœ‰éº¥å…‹é¢¨ä¸²æµ
                let streamToUse = localStream;
                if (!streamToUse || !streamToUse.active) {
                    console.log('ğŸ¤ è«‹æ±‚æ–°çš„éº¥å…‹é¢¨æ¬Šé™ (Groq Mode)');
                    streamToUse = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: true, noiseSuppression: true }
                    });
                    audioStream = streamToUse;
                }

                console.log('âœ… STT æ•´åˆå¼•æ“å·²å•Ÿå‹• (AssemblyAI + Groq + Gemini)');
                showInterimCaption('æ¨¡å¼ï¼šé«˜ç²¾ç¢ºåº¦äººåèˆ‡æ•¸æ“šè¾¨è­˜ (æ¯ 20 ç§’)...');

                isRecording = true;

                // ğŸŸ¢ ç¢ºä¿åˆ†æå™¨ç’°å¢ƒå·²å•Ÿå‹•
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // å•Ÿå‹•éŒ„éŸ³å¾ªç’°
                startRecordingLoop(streamToUse);
                return true;

            } catch (error) {
                console.error('èªéŸ³è¾¨è­˜åˆå§‹åŒ–å¤±æ•—:', error);
                alert('éº¥å…‹é¢¨å•Ÿå‹•å¤±æ•—ï¼š' + error.message);
                return false;
            }
        }

        // éŒ„éŸ³å¾ªç’° - å¸¶æœ‰ VAD (éœéŸ³åµæ¸¬) çš„ç©©å¥ç‰ˆæœ¬
        function startRecordingLoop(stream) {
            console.log('ğŸ”„ å•Ÿå‹•éŒ„éŸ³å¾ªç’°æ§åˆ¶...');
            const language = document.getElementById('languageSelect').value;

            function recordNextChunk() {
                if (!isRecording) return;

                audioChunks = [];
                speakingActivityDetected = false; // ğŸŸ¢ é‡ç½®æœ¬æ¬¡é€±æœŸçš„èªªè©±åµæ¸¬

                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                } catch (e) {
                    mediaRecorder = new MediaRecorder(stream);
                }

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const chunksToProcess = [...audioChunks];
                    const hadSpeech = speakingActivityDetected; // ğŸŸ¢ å…ˆæ•æ‰æœ¬é€±æœŸçš„åµæ¸¬çµæœ

                    // ç«‹å³é–‹å§‹ä¸‹ä¸€æ®µï¼ŒrecordNextChunk æœƒé‡ç½®å…¨åŸŸçš„ speakingActivityDetected
                    if (isRecording) {
                        recordNextChunk();
                    }

                    // ğŸ”´ å¹»è¦ºé é˜²ï¼šä½¿ç”¨å‰›æ‰æ•æ‰çš„ hadSpeech é€²è¡Œåˆ¤æ–·
                    if (!hadSpeech) {
                        console.log('ğŸ”‡ æœ¬é€±æœŸå®Œå…¨ç„¡è²éŸ³æ´»å‹•ï¼Œè·³é API èª¿ç”¨ (é˜²æ­¢å¹»è¦º)');
                        return;
                    }

                    if (chunksToProcess.length === 0) return;

                    const audioBlob = new Blob(chunksToProcess, { type: 'audio/webm' });
                    console.log('ğŸ“¦ åµæ¸¬åˆ°è²éŸ³æ´»å‹•ï¼Œæº–å‚™é€å¾€ Groq:', audioBlob.size, 'bytes');
                    if (audioBlob.size < 2000) return;

                    processAudioChunk(audioBlob, language);
                };

                mediaRecorder.start(); // æ¢å¾©é è¨­éŒ„éŸ³æ¨¡å¼

                // å®šæ™‚åœæ­¢ä¸¦è§¸ç™¼è½‰éŒ„
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, 20000); // 20 ç§’é€±æœŸ
            }

            recordNextChunk();
        }

        async function processAudioChunk(audioBlob, language) {
            const reader = new FileReader();
            reader.onloadend = async () => {
                const base64Audio = reader.result.split(',')[1];
                try {
                    const { data: { session } } = await supabaseClient.auth.getSession();
                    if (!session) return;

                    console.log('ğŸ“¤ åŒæ­¥å‘¼å« AssemblyAI (æ–‡å­—) èˆ‡ Groq (æ•¸å­—)...');

                    // 1. ä¸¦è¡Œå‘¼å« AssemblyAI èˆ‡ Groq
                    const [assemblyRes, groqRes] = await Promise.all([
                        fetch(ASSEMBLYAI_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${session.access_token}`
                            },
                            body: JSON.stringify({
                                audio: base64Audio,
                                language: language,
                                roomId: MEETING_ID,
                                wordBoost: roomWordBoost // æ”¯æ´äººåé—œéµå­—
                            })
                        }),
                        fetch(GROQ_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${session.access_token}`
                            },
                            body: JSON.stringify({
                                audio: base64Audio,
                                language: language,
                                roomId: MEETING_ID
                            })
                        })
                    ]);

                    let mainText = "";
                    let numericalTags = [];

                    // è™•ç† AssemblyAI çµæœ (ä¸»æ–‡å­—ä¾†æº)
                    if (assemblyRes.ok) {
                        const aaiBody = await assemblyRes.json();
                        mainText = (aaiBody.transcript || "").trim();
                        console.log('ğŸ¯ AssemblyAI è¾¨è­˜çµæœ:', mainText);
                    }

                    // è™•ç† Groq çµæœ (æ•¸å­—æ¨™ç±¤ä¾†æº)
                    if (groqRes.ok) {
                        const groqBody = await groqRes.json();
                        const groqTranscript = groqBody.transcript || "";
                        numericalTags = getNumericalTags(groqTranscript);
                        console.log('ğŸ¯ Groq åµæ¸¬æ•¸å­—æ¨™ç±¤:', numericalTags);
                    }

                    if (!mainText) return;

                    // 2. å‘¼å« Gemini é€²è¡Œæ¨™é»ç¬¦è™Ÿèˆ‡éŒ¯å­—ä¿®é£¾
                    console.log('âœ¨ è«‹æ±‚ Gemini å„ªåŒ–æ¨™é»èˆ‡éŒ¯å­—...');
                    let refinedText = mainText;
                    try {
                        const geminiRes = await fetch(GEMINI_PUNCTUATION_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${session.access_token}`
                            },
                            body: JSON.stringify({ text: mainText })
                        });

                        if (geminiRes.ok) {
                            const geminiBody = await geminiRes.json();
                            refinedText = geminiBody.result || mainText;
                            console.log('âœ… Gemini æ ¡æ­£å®Œæˆ:', refinedText);
                        }
                    } catch (gemError) {
                        console.warn('âš ï¸ Gemini æ ¡æ­£å¤±æ•—ï¼Œä½¿ç”¨åŸæ–‡å­—:', gemError);
                    }

                    // 3. é¡¯ç¤ºèˆ‡å„²å­˜
                    showLocalCaption(refinedText, numericalTags);
                    saveCaption(refinedText, true);

                } catch (error) {
                    console.error('éŸ³é¢‘è™•ç†é‚è¼¯é‡å¤§éŒ¯èª¤:', error);
                }
            };
            reader.readAsDataURL(audioBlob);
        }

        // æå–æ•¸å­—ä¸¦é¡¯ç¤ºå¿«ç…§
        function extractAndShowNumbers(text) {
            // é€™å€‹å‡½æ•¸å·²æ£„ç”¨ï¼Œæ•¸å­—æ¨™ç±¤ç¾åœ¨ç›´æ¥éŠœæ¥åœ¨å­—å¹•å…§å®¹ä¸­ã€‚
        }

        function stopAssemblyAIBatch() {
            console.log('â¹ï¸ åœæ­¢ AssemblyAI (Batch)...');
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            console.log('âœ… Batch éŒ„éŸ³å·²åœæ­¢');
        }


        // ========== PeerJS èªéŸ³é€šè©± ==========
        let peer = null;
        let localStream = null;
        let voiceChannel = null;
        let peerConnections = new Map();
        let isMicOn = true;
        let isSpeakerOn = true;

        async function initPeerVoice() {
            try {
                console.log('ğŸ“± é–‹å§‹åˆå§‹åŒ– PeerJS...');

                // å–å¾—éº¥å…‹é¢¨æ¬Šé™
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                console.log('âœ… å–å¾—éº¥å…‹é¢¨æ¬Šé™');

                // âš ï¸ é è¨­é—œé–‰éº¥å…‹é¢¨ï¼Œç­‰ä½¿ç”¨è€…æŒ‰ã€Œé–‹å§‹éŒ„éŸ³ã€æ‰é–‹å•Ÿ
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
                isMicOn = false;
                console.log('ğŸ”‡ éº¥å…‹é¢¨é è¨­é—œé–‰ï¼ŒæŒ‰ã€Œé–‹å§‹éŒ„éŸ³ã€æ‰æœƒé–‹å•Ÿ');

                // å»ºç«‹ PeerJS é€£æ¥ï¼ˆåŠ å…¥ STUN ä¼ºæœå™¨ä»¥æ”¹å–„æ‰‹æ©Ÿé€£æ¥ï¼‰
                const peerId = `${MEETING_ID}-${currentUser.id.substring(0, 8)}`;
                peer = new Peer(peerId, {
                    debug: 2,  // æé«˜é™¤éŒ¯ç­‰ç´š
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    console.log('âœ… PeerJS é€£æ¥æˆåŠŸ, ID:', id);
                    broadcastPeerId(id);

                    // ğŸ”„ å¿ƒè·³æ©Ÿåˆ¶ï¼šæ¯ 25 ç§’ ping ä¸€æ¬¡ä¿æŒé€£ç·š
                    if (window.peerHeartbeat) clearInterval(window.peerHeartbeat);
                    window.peerHeartbeat = setInterval(() => {
                        if (peer && !peer.destroyed && peer.open) {
                            // PeerJS æ²’æœ‰å…¬é–‹çš„ heartbeat APIï¼Œç”¨ socket ç‹€æ…‹æª¢æŸ¥ä»£æ›¿
                            console.log('ğŸ’“ PeerJS å¿ƒè·³æª¢æŸ¥ - é€£ç·šç‹€æ…‹:', peer.open ? 'æ­£å¸¸' : 'ä¸­æ–·');
                        }
                    }, 25000);
                });

                peer.on('call', (call) => {
                    console.log('ğŸ“ æ”¶åˆ°ä¾†é›»:', call.peer);
                    console.log('ğŸ“ æœ¬åœ°éŸ³è¨Šè»Œé“æ•¸:', localStream.getAudioTracks().length);
                    call.answer(localStream);
                    handleCall(call);
                });

                peer.on('error', (err) => {
                    console.error('âŒ PeerJS éŒ¯èª¤:', err.type, err);
                    // åªåœ¨éç¶²è·¯éŒ¯èª¤æ™‚é¡¯ç¤º alert
                    if (err.type !== 'network' && err.type !== 'disconnected') {
                        alert('èªéŸ³é€£ç·šéŒ¯èª¤: ' + err.type);
                    }
                });

                peer.on('disconnected', () => {
                    console.warn('âš ï¸ PeerJS é€£ç·šä¸­æ–·ï¼Œå˜—è©¦é‡é€£...');
                    // æ¸…é™¤å¿ƒè·³
                    if (window.peerHeartbeat) {
                        clearInterval(window.peerHeartbeat);
                        window.peerHeartbeat = null;
                    }
                    // å»¶é²é‡é€£ï¼Œé¿å…éæ–¼é »ç¹
                    setTimeout(() => {
                        if (peer && !peer.destroyed) {
                            peer.reconnect();
                        }
                    }, 1000);
                });

                updateVoiceButtons();

            } catch (error) {
                console.error('âŒ PeerJS åˆå§‹åŒ–å¤±æ•—:', error);
                alert('èªéŸ³åˆå§‹åŒ–å¤±æ•—: ' + error.message);
            }
        }

        function handleCall(call) {
            call.on('stream', (remoteStream) => {
                console.log('ğŸµ æ”¶åˆ°é ç«¯éŸ³è¨Š:', call.peer);
                playRemoteAudio(remoteStream, call.peer);
            });

            call.on('close', () => {
                console.log('ğŸ“´ é€šè©±çµæŸ:', call.peer);
                removeRemoteAudio(call.peer);
                peerConnections.delete(call.peer);
            });

            peerConnections.set(call.peer, call);
        }

        function playRemoteAudio(stream, peerId) {
            let audio = document.getElementById(`audio-${peerId}`);
            if (!audio) {
                audio = document.createElement('audio');
                audio.id = `audio-${peerId}`;
                audio.autoplay = true;
                audio.playsInline = true;
                audio.setAttribute('playsinline', '');  // iOS éœ€è¦
                audio.setAttribute('webkit-playsinline', '');  // èˆŠç‰ˆ iOS
                audio.style.display = 'none';
                document.body.appendChild(audio);
            }
            audio.srcObject = stream;
            audio.muted = !isSpeakerOn;
            audio.volume = 1.0;  // ç¢ºä¿éŸ³é‡æœ€å¤§

            // æ‰‹æ©Ÿ+é›»è…¦é€šç”¨çš„æ’­æ”¾å˜—è©¦
            const tryPlay = () => {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('ğŸ”Š éŸ³è¨Šæ’­æ”¾æˆåŠŸ:', peerId);
                    }).catch(err => {
                        console.warn('âš ï¸ éŸ³è¨Šæ’­æ”¾è¢«é˜»æ“‹:', err.name);
                        // è¨»å†Šå¤šç¨®äº’å‹•äº‹ä»¶
                        const resumeAudio = () => {
                            audio.muted = false;
                            audio.volume = 1.0;
                            audio.play().then(() => {
                                console.log('ğŸ”Š é‡è©¦æ’­æ”¾æˆåŠŸ');
                            }).catch(e => console.error('é‡è©¦æ’­æ”¾å¤±æ•—:', e));
                        };
                        // æ‰‹æ©Ÿéœ€è¦ touchstart/touchend
                        ['click', 'touchstart', 'touchend', 'keydown'].forEach(event => {
                            document.addEventListener(event, resumeAudio, { once: true });
                        });
                    });
                }
            };

            // å»¶é²æ’­æ”¾ï¼ˆæŸäº›æ‰‹æ©Ÿéœ€è¦ï¼‰
            setTimeout(tryPlay, 100);
        }

        function removeRemoteAudio(peerId) {
            const audio = document.getElementById(`audio-${peerId}`);
            if (audio) audio.remove();
        }

        async function broadcastPeerId(peerId) {
            voiceChannel = supabaseClient.channel(`voice-${MEETING_ID}`);

            voiceChannel.on('broadcast', { event: 'peer-join' }, async (payload) => {
                const remotePeerId = payload.payload.peerId;
                if (remotePeerId !== peerId && !peerConnections.has(remotePeerId)) {
                    console.log('ğŸ“ æ’¥æ‰“çµ¦:', remotePeerId);
                    const call = peer.call(remotePeerId, localStream);
                    handleCall(call);
                }
            });

            await voiceChannel.subscribe();

            voiceChannel.send({
                type: 'broadcast',
                event: 'peer-join',
                payload: { peerId }
            });
        }

        function updateVoiceButtons() {
            const micBtn = document.getElementById('micBtn');
            const speakerBtn = document.getElementById('speakerBtn');

            const speakerOnSvg = '<svg style="width:18px;height:18px;" viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';
            const speakerOffSvg = '<svg style="width:18px;height:18px;" viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>';
            const micOnSvg = '<svg style="width:18px;height:18px;" viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>';
            const micOffSvg = '<svg style="width:18px;height:18px;" viewBox="0 0 24 24" fill="none" stroke="#805ad5" stroke-width="2"><line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"/></svg>';

            if (micBtn) {
                micBtn.innerHTML = isMicOn ? micOnSvg : micOffSvg;
                micBtn.style.opacity = isMicOn ? '1' : '0.5';
            }
            if (speakerBtn) {
                speakerBtn.innerHTML = isSpeakerOn ? speakerOnSvg : speakerOffSvg;
                speakerBtn.style.opacity = isSpeakerOn ? '1' : '0.5';
            }
        }

        function toggleMic() {
            isMicOn = !isMicOn;
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicOn;
                });
            }
            updateVoiceButtons();
            console.log('ğŸ™ï¸ éº¥å…‹é¢¨:', isMicOn ? 'é–‹å•Ÿ' : 'é—œé–‰');
        }

        function toggleSpeaker() {
            isSpeakerOn = !isSpeakerOn;
            document.querySelectorAll('audio[id^="audio-"]').forEach(audio => {
                audio.muted = !isSpeakerOn;
            });
            updateVoiceButtons();
            console.log('ğŸ”Š å–‡å­:', isSpeakerOn ? 'é–‹å•Ÿ' : 'é—œé–‰');
        }

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥åŠŸèƒ½ã€‚è«‹ä½¿ç”¨ Chrome æˆ– Edge ç€è¦½å™¨ã€‚');
                return;
            }

            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognitionAPI();

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;
            recognition.lang = 'zh-TW';

            let finalTranscriptBuffer = '';
            let lastFinalTime = Date.now();

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (interimTranscript) {
                    showInterimCaption(interimTranscript);
                }

                if (finalTranscript) {
                    finalTranscriptBuffer += finalTranscript + ' ';
                    lastFinalTime = Date.now();

                    // ç«‹å³é¡¯ç¤ºæœ¬åœ°å­—å¹•ï¼ˆä¸ç­‰è³‡æ–™åº«ï¼‰
                    showLocalCaption(finalTranscript);

                    // æ¸›å°‘å»¶é²ï¼Œæ›´å¿«å„²å­˜
                    setTimeout(() => {
                        if (Date.now() - lastFinalTime >= 500 && finalTranscriptBuffer.trim()) {
                            saveCaption(finalTranscriptBuffer.trim());
                            finalTranscriptBuffer = '';
                        }
                    }, 600);
                }
            };

            let isRestarting = false;

            recognition.onerror = (event) => {
                console.error('èªéŸ³è­˜åˆ¥éŒ¯èª¤:', event.error);

                // åš´é‡éŒ¯èª¤ï¼Œåœæ­¢éŒ„éŸ³
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    alert('ç„¡æ³•å­˜å–éº¥å…‹é¢¨ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š');
                    stopRecording();
                    return;
                }

                // å¯æ¢å¾©çš„éŒ¯èª¤ï¼Œå˜—è©¦é‡å•Ÿ
                if ((event.error === 'no-speech' || event.error === 'aborted' || event.error === 'network') && isRecording && !isRestarting) {
                    isRestarting = true;
                    setTimeout(() => {
                        if (isRecording) {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error('é‡å•Ÿå¤±æ•—:', e);
                            }
                        }
                        isRestarting = false;
                    }, 300);
                }
            };

            recognition.onend = () => {
                console.log('èªéŸ³è­˜åˆ¥çµæŸ');
                if (isRecording && !isRestarting) {
                    isRestarting = true;
                    setTimeout(() => {
                        if (isRecording) {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error('é‡å•Ÿå¤±æ•—:', e);
                            }
                        }
                        isRestarting = false;
                    }, 300);
                }
            };

            console.log('âœ… èªéŸ³è­˜åˆ¥å·²åˆå§‹åŒ–');
        }

        // åˆå§‹åŒ–èªªè©±è€…æª¢æ¸¬
        async function initSpeakerDetection() {
            try {
                // å„ªå…ˆä½¿ç”¨ç¾æœ‰çš„ localStreamï¼Œé¿å…é‡è¤‡è«‹æ±‚éº¥å…‹é¢¨å°è‡´è¡çª
                let stream = localStream;
                if (!stream || !stream.active) {
                    stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                }

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.8;

                const microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                detectSpeaking();
                console.log('âœ… èªªè©±è€…æª¢æ¸¬å·²åˆå§‹åŒ–');

                // ğŸŸ¢ éš¨æ™‚è¿½è¹¤æœ€é«˜éŸ³é‡ä»¥ä¾¿è¨ºæ–·
                window.lastMaxAverage = 0;
                setInterval(() => {
                    if (isRecording) {
                        console.log(`ğŸ“Š ç›®å‰éŸ³é‡: [${Math.round(audioLevel)}] (é–€æª»: 5)`);
                    }
                }, 2000);

                return true;
            } catch (error) {
                console.error('ç„¡æ³•å­˜å–éº¥å…‹é¢¨:', error);
                return false;
            }
        }

        // æª¢æ¸¬èªªè©±
        function detectSpeaking() {
            if (!analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;

            // ğŸŸ¢ å„ªåŒ–ï¼šåªæœ‰åœ¨éŒ„éŸ³å•Ÿå‹•ä¸­æ‰è§¸ç™¼äº®æ¡†ï¼Œä½†åµæ¸¬å¾ªç’°æœ¬èº«æ°¸ä¸ä¸­æ–·
            const speaking = average > 5 && isRecording;
            audioLevel = average; // æ›´æ–°å…¨åŸŸè®Šæ•¸ä»¥ä¾›æ—¥èªŒé¡¯ç¤º

            if (speaking) {
                speakingActivityDetected = true;
            }

            if (speaking !== isSpeaking) {
                isSpeaking = speaking;
                updateSpeakingStatus(speaking);
            }

            // ğŸŸ¢ ä¿æŒå¾ªç’°ç©©å®šé‹è¡Œï¼Œé˜²æ­»çµ
            setTimeout(detectSpeaking, 100);
        }

        // æ›´æ–°èªªè©±ç‹€æ…‹
        async function updateSpeakingStatus(speaking) {
            const card = document.getElementById(`participant-${currentUser.id}`);
            if (card) {
                if (speaking) {
                    card.classList.add('speaking');
                } else {
                    card.classList.remove('speaking');
                }
            }

            // ğŸŸ¢ æ ¸å¿ƒä¿®æ­£ï¼šé™¤äº†è³‡æ–™åº«ï¼ŒåŒæ­¥æ›´æ–° Presence è®“å…¶ä»–äººä¹Ÿèƒ½å³æ™‚çœ‹åˆ°ã€Œèªªè©±ä¸­ã€çš„å¤–æ¡†
            if (window.roomChannel) {
                await window.roomChannel.track({
                    user_id: currentUser.id,
                    user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                    photo_url: currentUser.user_metadata?.avatar_url,
                    email: currentUser.email,
                    is_host: isOwner,
                    is_speaking: speaking, // åŒæ­¥èªªè©±ç‹€æ…‹
                    session_start_time: isOwner ? sessionStartTime : null,
                    online_at: new Date().toISOString(),
                });
            }

            // ç•°æ­¥æ›´æ–°è³‡æ–™åº«å‚™ä»½
            try {
                supabaseClient
                    .from('participants')
                    .update({ is_speaking: speaking })
                    .eq('meeting_id', MEETING_ID)
                    .eq('user_id', currentUser.id);
            } catch (error) {
                console.warn('DB èªªè©±ç‹€æ…‹æ›´æ–°ä¸ç©©å®šï¼Œä½†ä¸å½±éŸ¿ UI');
            }
        }

        // é¡¯ç¤ºå³æ™‚å­—å¹•ï¼ˆæœ¬åœ°ï¼‰
        function showInterimCaption(text) {
            const captionBar = document.getElementById('captionBar');
            const interimId = `interim-${currentUser.id}`;
            // ğŸŸ¢ ä¿®å¾©ï¼šå¾¹åº•æ¸…ç©ºï¼Œåªé¡¯ç¤ºæœ€æ–°çš„ä¸€å‰‡
            captionBar.innerHTML = '';

            const interimEl = document.createElement('div');
            interimEl.id = interimId;
            interimEl.className = 'caption-item interim-caption';
            interimEl.style.opacity = '0.5';
            captionBar.appendChild(interimEl);

            const userName = currentUser?.user_metadata?.full_name || currentUser?.email?.split('@')[0] || 'æˆ‘';
            interimEl.innerHTML = `
                <span class="caption-speaker">${userName}:</span>
                <span class="caption-text">${escapeHtml(text)}</span>
            `;
        }

        // ç«‹å³é¡¯ç¤ºæœ¬åœ°ç¢ºå®šå­—å¹•ï¼ˆä¸ç­‰è³‡æ–™åº«ï¼‰
        function showLocalCaption(text, tags = []) {
            const captionBar = document.getElementById('captionBar');
            const captionFull = document.getElementById('captionFull');

            // ğŸŸ¢ ä¿®å¾©ï¼šå¾¹åº•æ¸…ç©ºï¼Œåªé¡¯ç¤ºæœ€æ–°çš„ä¸€å‰‡
            captionBar.innerHTML = '';

            const userName = currentUser?.user_metadata?.full_name || currentUser?.email?.split('@')[0] || 'æˆ‘';
            const now = new Date().toLocaleTimeString('zh-TW');

            // ç”¢ç”Ÿæ¨™ç±¤ HTML
            const tagsHtml = tags.length > 0 ?
                `<div class="caption-tags">${tags.map(t => `<span class="caption-tag" title="Groq åµæ¸¬åˆ°çš„æ•¸æ“š">${t}</span>`).join('')}</div>` : '';

            // å­—å¹•æ¢
            const captionItem = document.createElement('div');
            captionItem.className = 'caption-item';
            captionItem.style.opacity = '0.9'; // æé«˜ä¸€é»é€æ˜åº¦
            captionItem.innerHTML = `
                <span class="caption-speaker">${userName}:</span>
                <span class="caption-text">${escapeHtml(text)}</span>
                ${tagsHtml}
            `;
            captionBar.appendChild(captionItem);

            // å®Œæ•´å­—å¹•
            const captionFullItem = document.createElement('div');
            captionFullItem.className = 'caption-item-full';
            captionFullItem.innerHTML = `
                <div class="caption-header">
                    <span class="caption-speaker">${userName}</span>
                    <span class="caption-time">${now}</span>
                </div>
                <div class="caption-text">${escapeHtml(text)}</div>
                ${tagsHtml}
            `;
            captionFull.appendChild(captionFullItem);

            setTimeout(() => {
                scrollToBottom(null, captionFull); // ğŸŸ¢ åƒ…å°å±•é–‹è¦–åœ–é€²è¡Œæ²å‹•
            }, 50);
        }

        // ä½¿ç”¨ OpenRouter AI æ·»åŠ æ¨™é»ç¬¦è™Ÿå’Œä¿®æ­£éŒ¯åˆ¥å­—
        const PUNCTUATION_API_URL = 'https://inzqsdelrwxxlbcumaiw.supabase.co/functions/v1/rapid-action';

        async function addPunctuation(text) {
            try {
                const response = await fetch(PUNCTUATION_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        mode: 'punctuation',
                        conversationText: text
                    })
                });

                if (!response.ok) {
                    console.warn('AI è™•ç†å¤±æ•—ï¼Œä½¿ç”¨åŸæ–‡');
                    return text;
                }

                const data = await response.json();
                return data.text || data.summary || text;
            } catch (error) {
                console.warn('AI è™•ç†éŒ¯èª¤:', error);
                return text;
            }
        }

        // å„²å­˜å­—å¹•åˆ°è³‡æ–™åº«ï¼ˆèƒŒæ™¯åŸ·è¡Œï¼Œä¸é˜»å¡ï¼‰
        async function saveCaption(text, alreadyProcessed = false) {
            try {
                let finalText = text;

                // å¦‚æœå°šæœªè™•ç†éï¼Œæ‰å‘¼å« AI åŠ æ¨™é»
                if (!alreadyProcessed) {
                    try {
                        finalText = await addPunctuation(text);
                        if (finalText !== text) {
                            console.log('ğŸ“ AI è™•ç†å¾Œ:', finalText);
                        }
                    } catch (e) {
                        console.warn('AI è™•ç†è·³é');
                    }
                }

                const sessionTaggedId = MEETING_ID + ':::' + sessionStartTime;

                // éåŒæ­¥å„²å­˜ï¼Œä¸ç­‰å¾…çµæœ
                supabaseClient
                    .from('captions')
                    .insert({
                        meeting_id: sessionTaggedId, // ğŸŸ¢ å­˜å…¥å¸¶æœ‰ Session æ¨™ç±¤çš„ ID
                        user_id: currentUser.id,
                        user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                        text: finalText,
                        language: document.getElementById('languageSelect').value
                    })
                    .then(({ error }) => {
                        if (error) console.error('å„²å­˜å­—å¹•å¤±æ•—:', error);
                        else console.log('âœ… å­—å¹•å·²å„²å­˜');
                    });
            } catch (error) {
                console.error('å„²å­˜å­—å¹•å¤±æ•—:', error);
            }
        }

        // é¡¯ç¤ºé ç«¯å­—å¹•
        function displayRemoteCaption(caption, shouldScroll = true) {
            const captionBar = document.getElementById('captionBar');
            const captionFull = document.getElementById('captionFull');

            // 1. è™•ç†æ”¶åˆç‹€æ…‹ä¸‹çš„å­—å¹•æ¢ (Caption Bar)
            updateCollapsedView(caption);

            // 2. è™•ç†å±•é–‹ç‹€æ…‹ä¸‹çš„å®Œæ•´è¦–åœ– (Caption Full)
            updateExpandedView(caption);

            // 3. è™•ç†æ²å‹•
            if (shouldScroll) {
                scrollToBottom(captionBar, captionFull);
            }
        }

        // --- å­—å¹•æ¢æ¸²æŸ“ (æ”¶åˆè¦–çª—) ---
        function updateCollapsedView(caption) {
            const captionBar = document.getElementById('captionBar');
            if (!captionBar) return;

            // ç§»é™¤å°æ‡‰ä½¿ç”¨è€…çš„å³æ™‚å­—å¹•å ä½
            const interimId = `interim-${caption.user_id}`;
            const interimEl = captionBar.querySelector(`#${interimId}`);
            if (interimEl) interimEl.remove();

            // ğŸŸ¢ ä¿®å¾©ï¼šåªé¡¯ç¤ºæœ€æ–°çš„ä¸€å‰‡å­—å¹•ï¼Œæ’å…¥å‰ç›´æ¥æ¸…ç©º
            captionBar.innerHTML = '';

            const tags = getNumericalTags(caption.text);
            const tagsHtml = tags.length > 0 ?
                `<div class="caption-tags">${tags.map(t => `<span class="caption-tag">${t}</span>`).join('')}</div>` : '';

            const captionItem = document.createElement('div');
            captionItem.className = 'caption-item';
            captionItem.innerHTML = `
                <span class="caption-speaker">${caption.user_name}:</span>
                <span class="caption-text">${escapeHtml(caption.text)}</span>
                ${tagsHtml}
            `;
            captionBar.appendChild(captionItem);
        }

        // --- å®Œæ•´è¦–åœ–æ¸²æŸ“ (å±•é–‹è¦–çª—) ---
        function updateExpandedView(caption) {
            const captionFull = document.getElementById('captionFull');
            if (!captionFull) return;

            const now = new Date(caption.created_at).toLocaleTimeString('zh-TW');
            const tags = getNumericalTags(caption.text);
            const tagsHtml = tags.length > 0 ?
                `<div class="caption-tags">${tags.map(t => `<span class="caption-tag">${t}</span>`).join('')}</div>` : '';

            const captionFullItem = document.createElement('div');
            captionFullItem.className = 'caption-item-full';
            captionFullItem.innerHTML = `
                <div class="caption-header">
                    <span class="caption-speaker">${caption.user_name}</span>
                    <span class="caption-time">${now}</span>
                </div>
                <div class="caption-text">${escapeHtml(caption.text)}</div>
                ${tagsHtml}
            `;
            captionFull.appendChild(captionFullItem);
        }

        function scrollToBottom(el1, el2) {
            requestAnimationFrame(() => {
                if (el1) el1.scrollTop = el1.scrollHeight + 1000;
                if (el2) el2.scrollTop = el2.scrollHeight + 1000;
                // å¼·åˆ¶åœ¨ä¸‹ä¸€å¹€å†åšä¸€æ¬¡ä»¥è§£æ±ºå‹•æ…‹å…§å®¹é«˜åº¦è®ŠåŒ–å»¶é²
                setTimeout(() => {
                    if (el1) el1.scrollTop = el1.scrollHeight + 1000;
                    if (el2) el2.scrollTop = el2.scrollHeight + 1000;
                }, 100);
            });
        }

        // HTML è½‰ç¾©
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åœæ­¢éŒ„éŸ³
        function stopRecording() {
            isRecording = false; // ğŸŸ¢ å„ªå…ˆè¨­ç‚º falseï¼Œè®“ detectSpeaking ç­‰å¾ªç’°èƒ½åµæ¸¬ä¸¦é€€å‡º
            isSpeaking = false;
            updateSpeakingStatus(false);

            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('åœæ­¢èªéŸ³è­˜åˆ¥å¤±æ•—:', e);
                }
            }
            if (typeof animationId !== 'undefined' && animationId) cancelAnimationFrame(animationId);
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) {
                    console.error('é—œé–‰éŸ³è¨Šä¸Šä¸‹æ–‡å¤±æ•—:', e);
                }
            }
            document.getElementById('startBtn').textContent = 'é–‹å§‹éŒ„éŸ³';
            document.getElementById('startBtn').classList.remove('btn-danger');
            document.getElementById('startBtn').classList.add('btn-primary');
        }

        // é›¢é–‹æœƒè­°
        async function leaveMeeting() {
            try {
                await supabaseClient
                    .from('participants')
                    .delete()
                    .eq('meeting_id', MEETING_ID)
                    .eq('user_id', currentUser.id);

                if (participantsChannel) {
                    participantsChannel.unsubscribe();
                    participantsChannel = null;
                }
                if (captionsChannel) {
                    captionsChannel.unsubscribe();
                    captionsChannel = null;
                }

                // ğŸ”´ é—œéµä¿®æ­£ï¼šé›¢é–‹æ™‚å¿…é ˆé¡¯å¼é›¢é–‹ Room Channel (Presence)
                // å¦å‰‡ Presence ç‹€æ…‹æœƒæš«ç•™åœ¨ä¼ºæœå™¨ä¸Šç›´åˆ°è¶…æ™‚ (Ghosting åŸå› )
                if (window.roomChannel) {
                    console.log('ğŸ‘‹ æ­£åœ¨åˆ‡æ–· Presence é€£ç·š...');
                    await window.roomChannel.untrack();
                    window.roomChannel.unsubscribe();
                    window.roomChannel = null;
                }

                // æ–·é–‹ PeerJS èªéŸ³
                if (peer) {
                    peerConnections.forEach(call => call.close());
                    peerConnections.clear();
                    peer.destroy();
                    peer = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                if (voiceChannel) {
                    voiceChannel.unsubscribe();
                    voiceChannel = null;
                }
                // ç§»é™¤æ‰€æœ‰é ç«¯éŸ³è¨Šå…ƒç´ 
                document.querySelectorAll('audio[id^="audio-"]').forEach(el => el.remove());

                // ğŸŸ¢ ä¿®æ­£ï¼šåªæœ‰ç•¶æˆ¿ä¸»ä¸»å‹•é»æ“ŠæŒ‰éˆ•é›¢é–‹æ™‚ï¼Œæ‰é—œé–‰æœƒè­° (is_active = false)
                if (isOwner) {
                    console.log('ğŸ‘‘ æˆ¿ä¸»æ­£å¼é—œé–‰æœƒè­°ä¸¦é›¢é–‹...');
                    await supabaseClient
                        .from('rooms')
                        .update({
                            session_start_time: null,
                            is_active: false
                        })
                        .eq('room_id', MEETING_ID);
                }

                console.log('âœ… å·²é›¢é–‹æœƒè­°');
            } catch (error) {
                console.error('é›¢é–‹æœƒè­°å¤±æ•—:', error);
            }
        }

        // ç¶å®šæŒ‰éˆ•äº‹ä»¶
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (!isRecording) {
                const speakerOK = await initSpeakerDetection();
                if (speakerOK) {
                    // ä½¿ç”¨ AssemblyAI Batch æ¨¡å¼
                    const speechOK = await startAssemblyAIBatch();
                    if (speechOK) {
                        isRecording = true;
                        document.getElementById('startBtn').textContent = 'åœæ­¢éŒ„éŸ³';
                        document.getElementById('startBtn').classList.remove('btn-primary');
                        document.getElementById('startBtn').classList.add('btn-danger');

                        if (localStream) {
                            localStream.getAudioTracks().forEach(track => {
                                track.enabled = true;
                            });
                            isMicOn = true;
                        }
                    }
                }
            } else {
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                    isMicOn = false;
                }
                stopAssemblyAIBatch();
                stopRecording();
            }
        });

        document.getElementById('leaveBtn').addEventListener('click', async () => {
            if (confirm('ç¢ºå®šè¦é›¢é–‹æœƒè­°å—ï¼Ÿ')) {
                stopAssemblyAIBatch();
                stopRecording();
                await leaveMeeting();
                // å›åˆ°æˆ¿é–“åˆ—è¡¨ï¼Œä¸ç™»å‡º
                window.location.href = 'index.html';
            }
        });


        document.getElementById('languageSelect').addEventListener('change', (e) => {
            if (recognition) {
                const wasRecording = isRecording;
                if (wasRecording) recognition.stop();
                recognition.lang = e.target.value;
                if (wasRecording) setTimeout(() => recognition.start(), 100);
            }
        });

        const toggleBtn = document.getElementById('toggleExpand');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                const container = document.getElementById('captionContainer');
                const captionFull = document.getElementById('captionFull');
                container.classList.toggle('expanded');
                toggleBtn.textContent = container.classList.contains('expanded') ? 'æ”¶åˆå®Œæ•´è¦–åœ–' : 'å±•é–‹å®Œæ•´è¦–åœ–';

                // å±•é–‹æ™‚è‡ªå‹•æ»¾å‹•åˆ°åº•éƒ¨
                if (container.classList.contains('expanded')) {
                    setTimeout(() => {
                        captionFull.scrollTop = captionFull.scrollHeight + 1000;
                    }, 100);
                }
            });
        }

        // é é¢é—œé–‰æ™‚é›¢é–‹æœƒè­°
        window.addEventListener('beforeunload', () => {
            leaveMeeting();
        });

        console.log('=== æœƒè­°å®¤åˆå§‹åŒ–å®Œæˆ ===');

        // æ³¨æ„ï¼šinitPeerVoice, handleCall, playRemoteAudio ç­‰å‡½æ•¸å·²åœ¨ä¸Šæ–¹å®šç¾©

        // å–‡å­é–‹é—œ
        document.getElementById('speakerBtn').addEventListener('click', () => {
            isSpeakerOn = !isSpeakerOn;
            // æ§åˆ¶æ‰€æœ‰é ç«¯éŸ³è¨Šçš„éœéŸ³
            document.querySelectorAll('audio[id^="audio-"]').forEach(audio => {
                audio.muted = !isSpeakerOn;
            });
            updateVoiceButtons();
            console.log('å–‡å­:', isSpeakerOn ? 'é–‹å•Ÿ' : 'é—œé–‰');
        });

        // éŸ³è¨Šè§£é–åŠŸèƒ½
        let audioUnlocked = false;

        function showAudioUnlockPrompt() {
            if (audioUnlocked) return;
            const overlay = document.getElementById('audioUnlockOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
            }
        }

        function unlockAudio() {
            audioUnlocked = true;
            const overlay = document.getElementById('audioUnlockOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }

            // å˜—è©¦æ’­æ”¾æ‰€æœ‰ç¾æœ‰çš„éŸ³è¨Šå…ƒç´ 
            document.querySelectorAll('audio[id^="audio-"]').forEach(audio => {
                audio.play().then(() => {
                    console.log('ğŸ”Š éŸ³è¨Šå·²è§£é–ä¸¦æ’­æ”¾');
                }).catch(e => console.error('æ’­æ”¾å¤±æ•—:', e));
            });

            console.log('âœ… éŸ³è¨Šå·²è§£é–');
        }

        // ç¶å®šè§£é–æŒ‰éˆ•
        const unlockBtn = document.getElementById('unlockAudioBtn');
        if (unlockBtn) {
            unlockBtn.addEventListener('click', unlockAudio);
            unlockBtn.addEventListener('touchend', unlockAudio);  // æ‰‹æ©Ÿè§¸æ§
        }

        // ä»»ä½•ä½¿ç”¨è€…äº’å‹•éƒ½è§£é–éŸ³è¨Šï¼ˆåŒ…æ‹¬æ‰‹æ©Ÿè§¸æ§ï¼‰
        ['click', 'touchstart', 'touchend'].forEach(event => {
            document.addEventListener(event, () => {
                if (!audioUnlocked) {
                    unlockAudio();
                }
            }, { once: true });
        });

        // é€²å…¥æœƒè­°å®¤å¾Œè‡ªå‹•é€£æ¥èªéŸ³
        setTimeout(() => {
            if (currentUser) {
                initPeerVoice();
                // é¡¯ç¤ºè§£é–æç¤º
                showAudioUnlockPrompt();
            }
        }, 2000);
    </script>
</body>

</html>