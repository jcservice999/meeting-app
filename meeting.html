<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>æœƒè­°å®¤ (å¤šäºº) - å³æ™‚èªéŸ³è½‰æ–‡å­—</title>
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/meeting.css">

    <!-- Supabase SDK -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <!-- PeerJS SDK -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>

<body>
    <div class="meeting-container">
        <!-- é ‚éƒ¨å·¥å…·åˆ— -->
        <header class="meeting-header">
            <div class="header-left">
                <h1>ğŸ¤ æœƒè­°å®¤ (å¤šäººæ¨¡å¼)</h1>
                <span id="participantCount" class="participant-count">è¼‰å…¥ä¸­...</span>
            </div>
            <div class="header-right">
                <select id="languageSelect" class="language-select">
                    <option value="zh-TW">ä¸­æ–‡</option>
                    <option value="en-US">English</option>
                </select>
                <button id="micBtn" class="btn-secondary" title="éº¥å…‹é¢¨">ğŸ™ï¸</button>
                <button id="speakerBtn" class="btn-secondary" title="å—‡å­">ğŸ”Š</button>
                <button id="startBtn" class="btn-primary">é–‹å§‹éŒ„éŸ³</button>
                <button id="leaveBtn" class="btn-danger">é›¢é–‹æœƒè­°</button>
            </div>
        </header>

        <!-- ä¸»è¦å…§å®¹å€ -->
        <main class="meeting-main">
            <!-- åƒèˆ‡è€…ç¶²æ ¼ -->
            <div id="participantGrid" class="participant-grid">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </main>

        <!-- å­—å¹•æ¢ - å›ºå®šåœ¨åº•éƒ¨ -->
        <div id="captionContainer" class="caption-container">
            <div class="caption-header">
                <span>å³æ™‚å­—å¹• (å¤šäººåŒæ­¥)</span>
                <button id="toggleCaptions" class="btn-toggle">å±•é–‹ â–²</button>
            </div>
            <div id="captionBar" class="caption-bar">
                é»æ“Šã€Œé–‹å§‹éŒ„éŸ³ã€é–‹å§‹...
            </div>
            <div id="captionFull" class="caption-full">
                <!-- å®Œæ•´å°è©±é¡¯ç¤º -->
            </div>
        </div>
    </div>

    <script>
        console.log('=== å¤šäººæœƒè­°å®¤åˆå§‹åŒ– ===');

        // å¾ URL å–å¾—æˆ¿é–“ ID
        const urlParams = new URLSearchParams(window.location.search);
        const MEETING_ID = urlParams.get('room') || 'main-room';
        console.log('æœƒè­°å®¤ ID:', MEETING_ID);

        // åˆå§‹åŒ– Supabase
        const { createClient } = supabase;
        const supabaseClient = createClient(
            'https://inzqsdelrwxxlbcumaiw.supabase.co',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImluenFzZGVscnd4eGxiY3VtYWl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3MTQzMjksImV4cCI6MjA4MzI5MDMyOX0.XBrMbxu_vcNQb55v6OZNoB-Mm1w-A2OtJk1AAgofjg0'
        );
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImluenFzZGVscnd4eGxiY3VtYWl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3MTQzMjksImV4cCI6MjA4MzI5MDMyOX0.XBrMbxu_vcNQb55v6OZNoB-Mm1w-A2OtJk1AAgofjg0';


        let currentUser = null;
        let recognition = null;
        let isRecording = false;
        let isSpeaking = false;
        let audioContext = null;
        let analyser = null;
        let animationId = null;
        let participants = new Map();
        let participantsChannel = null;
        let captionsChannel = null;

        // PeerJS èªéŸ³é€šè©±
        let peer = null;
        let localStream = null;
        let peerConnections = new Map(); // peerId -> call
        let isMicOn = true;
        let isSpeakerOn = true;
        let voiceChannel = null;

        // æª¢æŸ¥æˆ¿é–“å­˜å–æ¬Šé™
        async function checkRoomAccess() {
            // å¦‚æœæ˜¯é è¨­æˆ¿é–“ï¼Œä¸æª¢æŸ¥æ¬Šé™
            if (MEETING_ID === 'main-room') {
                return true;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('room_access')
                    .select('*')
                    .eq('room_id', MEETING_ID)
                    .eq('email', currentUser.email)
                    .single();

                if (error || !data) {
                    alert('æ‚¨æ²’æœ‰æ¬Šé™é€²å…¥æ­¤æœƒè­°å®¤');
                    window.location.href = 'index.html';
                    return false;
                }

                console.log('âœ… æ¬Šé™é©—è­‰é€šé');
                return true;

            } catch (error) {
                console.error('æ¬Šé™æª¢æŸ¥å¤±æ•—:', error);
                alert('æ¬Šé™æª¢æŸ¥å¤±æ•—');
                window.location.href = 'index.html';
                return false;
            }
        }

        // ç«‹å³æª¢æŸ¥ç™»å…¥ç‹€æ…‹ï¼ˆåœ¨é é¢è¼‰å…¥æ™‚ï¼‰
        (async function checkAuthImmediately() {
            const { data: { session } } = await supabaseClient.auth.getSession();
            if (!session) {
                console.log('âŒ æœªç™»å…¥ï¼Œè·³è½‰åˆ°é¦–é ');
                alert('è«‹å…ˆç™»å…¥');
                window.location.href = 'index.html';
                return;
            }
            console.log('âœ… å·²ç™»å…¥ï¼Œç¹¼çºŒè¼‰å…¥æœƒè­°å®¤');
        })();

        // æª¢æŸ¥ç™»å…¥ç‹€æ…‹ä¸¦åŠ å…¥æœƒè­°
        supabaseClient.auth.getSession().then(async ({ data: { session } }) => {
            if (!session) {
                window.location.href = 'index.html';
                return;
            }

            currentUser = session.user;
            console.log('âœ… ä½¿ç”¨è€…å·²ç™»å…¥', currentUser.email);

            // æª¢æŸ¥æˆ¿é–“æ¬Šé™
            const hasAccess = await checkRoomAccess();
            if (!hasAccess) return;

            // åŠ å…¥æœƒè­°å®¤
            await joinMeeting();

            // è¨‚é–±åƒèˆ‡è€…è®ŠåŒ–
            subscribeToParticipants();

            // è¨‚é–±å­—å¹•
            subscribeToCaptions();

            // åˆå§‹åŒ–èªéŸ³è­˜åˆ¥
            initSpeechRecognition();

            // è¼‰å…¥ç¾æœ‰åƒèˆ‡è€…
            await loadParticipants();
        });

        // åŠ å…¥æœƒè­°å®¤
        async function joinMeeting() {
            try {
                const { error } = await supabaseClient
                    .from('participants')
                    .upsert({
                        meeting_id: MEETING_ID,
                        user_id: currentUser.id,
                        user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                        photo_url: currentUser.user_metadata?.avatar_url,
                        status: 'online',
                        is_speaking: false
                    }, {
                        onConflict: 'meeting_id,user_id'
                    });

                if (error) throw error;
                console.log('âœ… å·²åŠ å…¥æœƒè­°å®¤');
            } catch (error) {
                console.error('åŠ å…¥æœƒè­°å¤±æ•—:', error);
            }
        }

        // è¨‚é–±åƒèˆ‡è€…è®ŠåŒ–
        function subscribeToParticipants() {
            participantsChannel = supabaseClient
                .channel('participants-changes')
                .on('postgres_changes', {
                    event: '*',
                    schema: 'public',
                    table: 'participants',
                    filter: `meeting_id=eq.${MEETING_ID}`
                }, (payload) => {
                    console.log('åƒèˆ‡è€…è®ŠåŒ–:', payload);
                    loadParticipants();
                })
                .subscribe();
        }

        // è¨‚é–±å­—å¹•
        function subscribeToCaptions() {
            captionsChannel = supabaseClient
                .channel('captions-changes')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'captions',
                    filter: `meeting_id=eq.${MEETING_ID}`
                }, (payload) => {
                    console.log('æ–°å­—å¹•:', payload.new);
                    displayRemoteCaption(payload.new);
                })
                .subscribe();
        }

        // è¼‰å…¥åƒèˆ‡è€…åˆ—è¡¨
        async function loadParticipants() {
            try {
                const { data, error } = await supabaseClient
                    .from('participants')
                    .select('*')
                    .eq('meeting_id', MEETING_ID)
                    .eq('status', 'online');

                if (error) throw error;

                participants.clear();
                data.forEach(p => participants.set(p.user_id, p));

                updateParticipantGrid();
                updateParticipantCount();
            } catch (error) {
                console.error('è¼‰å…¥åƒèˆ‡è€…å¤±æ•—:', error);
            }
        }

        // æ›´æ–°åƒèˆ‡è€…ç¶²æ ¼
        function updateParticipantGrid() {
            const grid = document.getElementById('participantGrid');
            grid.innerHTML = '';

            // è¨­å®š data-count å±¬æ€§ä¾› CSS ä½¿ç”¨
            grid.setAttribute('data-count', participants.size);

            participants.forEach((participant, userId) => {
                const isMe = userId === currentUser.id;
                const card = document.createElement('div');
                card.className = 'participant-card';
                card.id = `participant-${userId}`;

                if (participant.is_speaking) {
                    card.classList.add('speaking');
                }

                card.innerHTML = `
                    <div class="participant-photo">
                        ${participant.photo_url
                        ? `<img src="${participant.photo_url}" alt="${participant.user_name}">`
                        : `<div class="photo-placeholder">${participant.user_name.charAt(0).toUpperCase()}</div>`
                    }
                        <div class="participant-name">${participant.user_name}${isMe ? ' (æˆ‘)' : ''}</div>
                    </div>
                `;

                grid.appendChild(card);
            });
        }

        // æ›´æ–°åƒèˆ‡è€…è¨ˆæ•¸
        function updateParticipantCount() {
            document.getElementById('participantCount').textContent = `${participants.size} äºº`;
        }



        // AssemblyAI Streaming èªéŸ³è½‰éŒ„è¨­å®š
        const ASSEMBLYAI_TOKEN_URL = 'https://inzqsdelrwxxlbcumaiw.supabase.co/functions/v1/assemblyai-token';

        let assemblySocket = null;
        let audioStream = null;
        let assemblyAudioContext = null;
        let audioWorklet = null;
        let mediaRecorder = null;
        let recordingInterval = null;
        let audioChunks = [];

        // é–‹å§‹ AssemblyAI Streaming éŒ„éŸ³
        async function startDeepgramStream() {
            try {
                // å–å¾—éº¥å…‹é¢¨æ¬Šé™
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000 // AssemblyAI éœ€è¦ 16kHz
                    }
                });

                // å–å¾— AssemblyAI Streaming Token
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (!session) {
                    throw new Error('è«‹å…ˆç™»å…¥');
                }

                const tokenRes = await fetch(ASSEMBLYAI_TOKEN_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({ roomId: MEETING_ID })
                });

                const tokenData = await tokenRes.json();
                if (tokenData.error) {
                    throw new Error(tokenData.error);
                }

                const language = document.getElementById('languageSelect').value;
                // é¸æ“‡æ¨¡å‹ï¼šè‹±æ–‡ç”¨ englishï¼Œå…¶ä»–ç”¨ multi
                const speechModel = language === 'en-US' ? 'universal-streaming-english' : 'universal-streaming-multi';

                // å»ºç«‹ WebSocket é€£æ¥ï¼ˆæ–°çš„ v3 Universal Streaming APIï¼‰
                const wsUrl = `wss://streaming.assemblyai.com/v3/ws?sample_rate=16000&token=${tokenData.token}&speech_model=${speechModel}&format_turns=true`;
                assemblySocket = new WebSocket(wsUrl);

                assemblySocket.onopen = () => {
                    console.log('âœ… AssemblyAI Universal Streaming å·²é€£æ¥');
                    showInterimCaption('æ­£åœ¨è†è½...');
                    startAudioStreaming();
                };

                assemblySocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    // æ–°çš„ v3 API è¨Šæ¯æ ¼å¼
                    if (data.type === 'Turn' && data.transcript) {
                        if (data.end_of_turn) {
                            console.log('âœ… å®Œæ•´å¥å­:', data.transcript);
                            showLocalCaption(data.transcript);
                            saveCaption(data.transcript);
                        } else {
                            console.log('â³ å³æ™‚è½‰éŒ„:', data.transcript);
                            showInterimCaption(data.transcript);
                        }
                    } else if (data.type === 'Begin') {
                        console.log('ğŸ“ Session é–‹å§‹:', data.id);
                    } else if (data.type === 'Termination') {
                        console.log('ğŸ“ Session çµæŸ');
                    } else if (data.type === 'Error') {
                        console.error('âŒ AssemblyAI éŒ¯èª¤:', data.message);
                    }
                };

                assemblySocket.onerror = (error) => {
                    console.error('âŒ WebSocket éŒ¯èª¤:', error);
                };

                assemblySocket.onclose = (event) => {
                    console.log('ğŸ”Œ WebSocket å·²é—œé–‰:', event.code, event.reason);
                    if (event.code === 4001 || event.code === 4000) {
                        alert('AssemblyAI èªè­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ API Key');
                    }
                };

                return true;

            } catch (error) {
                console.error('èªéŸ³è¾¨è­˜åˆå§‹åŒ–å¤±æ•—:', error);
                if (error.message.includes('No active')) {
                    alert('è«‹å…ˆåœ¨ã€ŒAssemblyAI API è¨­å®šã€ä¸­æ–°å¢ API Key');
                    window.location.href = 'settings.html';
                } else {
                    alert('èªéŸ³è¾¨è­˜åˆå§‹åŒ–å¤±æ•—ï¼š' + error.message);
                }
                return false;
            }
        }

        // é–‹å§‹éŸ³è¨Šä¸²æµåˆ° WebSocket
        function startAudioStreaming() {
            if (!audioStream || !assemblySocket) return;

            assemblyAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });

            const source = assemblyAudioContext.createMediaStreamSource(audioStream);
            const processor = assemblyAudioContext.createScriptProcessor(4096, 1, 1);

            source.connect(processor);
            processor.connect(assemblyAudioContext.destination);

            processor.onaudioprocess = (event) => {
                if (assemblySocket && assemblySocket.readyState === WebSocket.OPEN) {
                    const inputData = event.inputBuffer.getChannelData(0);

                    // è½‰æ›ç‚º 16-bit PCM
                    const pcmData = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        pcmData[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                    }

                    // v3 API: ç›´æ¥å‚³é€ raw binary audio (ä¸æ˜¯ JSON)
                    assemblySocket.send(pcmData.buffer);
                }
            };

            audioWorklet = processor;
        }

        // VAD è¨­å®š
        const VAD_THRESHOLD = 15;  // éŸ³é‡é–¾å€¼ï¼Œå¯èª¿æ•´ (0-255)
        let vadMaxVolume = 0;      // éŒ„éŸ³æœŸé–“çš„æœ€å¤§éŸ³é‡
        let vadAnalyser = null;    // VAD å°ˆç”¨çš„åˆ†æå™¨
        let vadInterval = null;    // VAD æª¢æ¸¬å®šæ™‚å™¨

        // é–‹å§‹ VAD ç›£æ¸¬
        function startVADMonitoring(stream) {
            const vadContext = new (window.AudioContext || window.webkitAudioContext)();
            vadAnalyser = vadContext.createAnalyser();
            vadAnalyser.fftSize = 256;
            vadAnalyser.smoothingTimeConstant = 0.3;

            const source = vadContext.createMediaStreamSource(stream);
            source.connect(vadAnalyser);

            // æ¯ 100ms æª¢æ¸¬ä¸€æ¬¡éŸ³é‡
            vadInterval = setInterval(() => {
                if (!vadAnalyser) return;
                const dataArray = new Uint8Array(vadAnalyser.frequencyBinCount);
                vadAnalyser.getByteFrequencyData(dataArray);
                const avg = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;
                if (avg > vadMaxVolume) {
                    vadMaxVolume = avg;
                }
            }, 100);

            console.log('âœ… VAD ç›£æ¸¬å·²å•Ÿå‹•');
        }

        // åœæ­¢ VAD ç›£æ¸¬
        function stopVADMonitoring() {
            if (vadInterval) {
                clearInterval(vadInterval);
                vadInterval = null;
            }
            vadAnalyser = null;
        }

        // æ³¨æ„ï¼šstartRecordingLoop å·²ç§»é™¤ï¼Œæ”¹ç”¨ WebSocket å³æ™‚ä¸²æµ (startAudioStreaming)

        // åœæ­¢ AssemblyAI Streaming
        function stopDeepgramStream() {
            // é—œé–‰ WebSocket
            if (assemblySocket) {
                assemblySocket.close();
                assemblySocket = null;
            }

            // åœæ­¢ AudioContext
            if (assemblyAudioContext) {
                assemblyAudioContext.close();
                assemblyAudioContext = null;
            }

            // åœæ­¢éŸ³è¨Šä¸²æµ
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }

            audioWorklet = null;
            console.log('â¹ï¸ AssemblyAI Streaming å·²åœæ­¢');
        }


        // åˆå§‹åŒ–èªéŸ³è­˜åˆ¥

        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥åŠŸèƒ½ã€‚è«‹ä½¿ç”¨ Chrome æˆ– Edge ç€è¦½å™¨ã€‚');
                return;
            }

            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognitionAPI();

            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 3;
            recognition.lang = 'zh-TW';

            let finalTranscriptBuffer = '';
            let lastFinalTime = Date.now();

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (interimTranscript) {
                    showInterimCaption(interimTranscript);
                }

                if (finalTranscript) {
                    finalTranscriptBuffer += finalTranscript + ' ';
                    lastFinalTime = Date.now();

                    // ç«‹å³é¡¯ç¤ºæœ¬åœ°å­—å¹•ï¼ˆä¸ç­‰è³‡æ–™åº«ï¼‰
                    showLocalCaption(finalTranscript);

                    // æ¸›å°‘å»¶é²ï¼Œæ›´å¿«å„²å­˜
                    setTimeout(() => {
                        if (Date.now() - lastFinalTime >= 500 && finalTranscriptBuffer.trim()) {
                            saveCaption(finalTranscriptBuffer.trim());
                            finalTranscriptBuffer = '';
                        }
                    }, 600);
                }
            };

            let isRestarting = false;

            recognition.onerror = (event) => {
                console.error('èªéŸ³è­˜åˆ¥éŒ¯èª¤:', event.error);

                // åš´é‡éŒ¯èª¤ï¼Œåœæ­¢éŒ„éŸ³
                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    alert('ç„¡æ³•å­˜å–éº¥å…‹é¢¨ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š');
                    stopRecording();
                    return;
                }

                // å¯æ¢å¾©çš„éŒ¯èª¤ï¼Œå˜—è©¦é‡å•Ÿ
                if ((event.error === 'no-speech' || event.error === 'aborted' || event.error === 'network') && isRecording && !isRestarting) {
                    isRestarting = true;
                    setTimeout(() => {
                        if (isRecording) {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error('é‡å•Ÿå¤±æ•—:', e);
                            }
                        }
                        isRestarting = false;
                    }, 300);
                }
            };

            recognition.onend = () => {
                console.log('èªéŸ³è­˜åˆ¥çµæŸ');
                if (isRecording && !isRestarting) {
                    isRestarting = true;
                    setTimeout(() => {
                        if (isRecording) {
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error('é‡å•Ÿå¤±æ•—:', e);
                            }
                        }
                        isRestarting = false;
                    }, 300);
                }
            };

            console.log('âœ… èªéŸ³è­˜åˆ¥å·²åˆå§‹åŒ–');
        }

        // åˆå§‹åŒ–èªªè©±è€…æª¢æ¸¬
        async function initSpeakerDetection() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.8;

                const microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                detectSpeaking();
                console.log('âœ… èªªè©±è€…æª¢æ¸¬å·²åˆå§‹åŒ–');
                return true;
            } catch (error) {
                console.error('ç„¡æ³•å­˜å–éº¥å…‹é¢¨:', error);
                return false;
            }
        }

        // æª¢æ¸¬èªªè©±
        function detectSpeaking() {
            if (!analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;

            const speaking = average > 25;
            if (speaking !== isSpeaking) {
                isSpeaking = speaking;
                updateSpeakingStatus(speaking);
            }

            animationId = requestAnimationFrame(detectSpeaking);
        }

        // æ›´æ–°èªªè©±ç‹€æ…‹
        async function updateSpeakingStatus(speaking) {
            const card = document.getElementById(`participant-${currentUser.id}`);
            if (card) {
                if (speaking) {
                    card.classList.add('speaking');
                } else {
                    card.classList.remove('speaking');
                }
            }

            // æ›´æ–°è³‡æ–™åº«
            try {
                await supabaseClient
                    .from('participants')
                    .update({ is_speaking: speaking })
                    .eq('meeting_id', MEETING_ID)
                    .eq('user_id', currentUser.id);
            } catch (error) {
                console.error('æ›´æ–°èªªè©±ç‹€æ…‹å¤±æ•—:', error);
            }
        }

        // é¡¯ç¤ºå³æ™‚å­—å¹•ï¼ˆæœ¬åœ°ï¼‰
        function showInterimCaption(text) {
            const captionBar = document.getElementById('captionBar');
            // ä½¿ç”¨ user_id ä¾†å€åˆ†ä¸åŒä½¿ç”¨è€…çš„å³æ™‚å­—å¹•
            const interimId = `interim-${currentUser.id}`;
            let interimEl = captionBar.querySelector(`#${interimId}`);

            if (!interimEl) {
                interimEl = document.createElement('div');
                interimEl.id = interimId;
                interimEl.className = 'caption-item interim-caption';
                interimEl.style.opacity = '0.5';
                captionBar.appendChild(interimEl);
            }

            const userName = currentUser?.user_metadata?.full_name || currentUser?.email?.split('@')[0] || 'æˆ‘';
            interimEl.innerHTML = `
                <span class="caption-speaker">${userName}:</span>
                <span class="caption-text">${escapeHtml(text)}</span>
            `;

            captionBar.scrollTop = captionBar.scrollHeight;
        }

        // ç«‹å³é¡¯ç¤ºæœ¬åœ°ç¢ºå®šå­—å¹•ï¼ˆä¸ç­‰è³‡æ–™åº«ï¼‰
        function showLocalCaption(text) {
            const captionBar = document.getElementById('captionBar');
            const captionFull = document.getElementById('captionFull');

            // ç§»é™¤å³æ™‚å­—å¹•
            const interimId = `interim-${currentUser.id}`;
            const interimEl = captionBar.querySelector(`#${interimId}`);
            if (interimEl) interimEl.remove();

            const userName = currentUser?.user_metadata?.full_name || currentUser?.email?.split('@')[0] || 'æˆ‘';
            const now = new Date().toLocaleTimeString('zh-TW');

            // å­—å¹•æ¢ï¼šåªä¿ç•™æœ€è¿‘ 3 è¡Œ
            const captionItem = document.createElement('div');
            captionItem.className = 'caption-item';
            captionItem.style.opacity = '0.7';
            captionItem.innerHTML = `
                <span class="caption-speaker">${userName}:</span>
                <span class="caption-text">${escapeHtml(text)}</span>
            `;
            captionBar.appendChild(captionItem);

            // åªä¿ç•™æœ€è¿‘ 3 è¡Œ
            const items = captionBar.querySelectorAll('.caption-item:not(.interim-caption)');
            if (items.length > 3) {
                for (let i = 0; i < items.length - 3; i++) {
                    items[i].remove();
                }
            }

            // å®Œæ•´å­—å¹•ï¼šä¿ç•™æ‰€æœ‰
            const captionFullItem = document.createElement('div');
            captionFullItem.className = 'caption-item-full';
            captionFullItem.style.opacity = '0.7';
            captionFullItem.innerHTML = `
                <div class="caption-header">
                    <span class="caption-speaker">${userName}</span>
                    <span class="caption-time">${now}</span>
                </div>
                <div class="caption-text">${escapeHtml(text)}</div>
            `;
            captionFull.appendChild(captionFullItem);

            captionBar.scrollTop = captionBar.scrollHeight;
            captionFull.scrollTop = captionFull.scrollHeight;
        }

        // å„²å­˜å­—å¹•åˆ°è³‡æ–™åº«ï¼ˆèƒŒæ™¯åŸ·è¡Œï¼Œä¸é˜»å¡ï¼‰
        async function saveCaption(text) {
            try {
                // éåŒæ­¥å„²å­˜ï¼Œä¸ç­‰å¾…çµæœ
                supabaseClient
                    .from('captions')
                    .insert({
                        meeting_id: MEETING_ID,
                        user_id: currentUser.id,
                        user_name: currentUser.user_metadata?.full_name || currentUser.email.split('@')[0],
                        text: text,
                        language: document.getElementById('languageSelect').value
                    })
                    .then(({ error }) => {
                        if (error) console.error('å„²å­˜å­—å¹•å¤±æ•—:', error);
                        else console.log('âœ… å­—å¹•å·²å„²å­˜');
                    });
            } catch (error) {
                console.error('å„²å­˜å­—å¹•å¤±æ•—:', error);
            }
        }

        // é¡¯ç¤ºé ç«¯å­—å¹•
        function displayRemoteCaption(caption) {
            const captionBar = document.getElementById('captionBar');
            const captionFull = document.getElementById('captionFull');

            // ç§»é™¤å°æ‡‰ä½¿ç”¨è€…çš„å³æ™‚å­—å¹•
            const interimId = `interim-${caption.user_id}`;
            const interimEl = captionBar.querySelector(`#${interimId}`);
            if (interimEl) interimEl.remove();

            const now = new Date(caption.created_at).toLocaleTimeString('zh-TW');

            // å­—å¹•æ¢ï¼šåªä¿ç•™æœ€è¿‘ 3 è¡Œ
            const captionItem = document.createElement('div');
            captionItem.className = 'caption-item';
            captionItem.innerHTML = `
                <span class="caption-speaker">${caption.user_name}:</span>
                <span class="caption-text">${escapeHtml(caption.text)}</span>
            `;
            captionBar.appendChild(captionItem);

            // åªä¿ç•™æœ€è¿‘ 3 è¡Œ
            const items = captionBar.querySelectorAll('.caption-item:not(.interim-caption)');
            if (items.length > 3) {
                for (let i = 0; i < items.length - 3; i++) {
                    items[i].remove();
                }
            }

            // å®Œæ•´å­—å¹•ï¼šä¿ç•™æ‰€æœ‰
            const captionFullItem = document.createElement('div');
            captionFullItem.className = 'caption-item-full';
            captionFullItem.innerHTML = `
                <div class="caption-header">
                    <span class="caption-speaker">${caption.user_name}</span>
                    <span class="caption-time">${now}</span>
                </div>
                <div class="caption-text">${escapeHtml(caption.text)}</div>
            `;
            captionFull.appendChild(captionFullItem);

            captionBar.scrollTop = captionBar.scrollHeight;
            captionFull.scrollTop = captionFull.scrollHeight;
        }

        // HTML è½‰ç¾©
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åœæ­¢éŒ„éŸ³
        function stopRecording() {
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('åœæ­¢èªéŸ³è­˜åˆ¥å¤±æ•—:', e);
                }
            }
            if (animationId) cancelAnimationFrame(animationId);
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (e) {
                    console.error('é—œé–‰éŸ³è¨Šä¸Šä¸‹æ–‡å¤±æ•—:', e);
                }
            }
            isRecording = false;
            isSpeaking = false;
            updateSpeakingStatus(false);
            document.getElementById('startBtn').textContent = 'é–‹å§‹éŒ„éŸ³';
            document.getElementById('startBtn').classList.remove('btn-danger');
            document.getElementById('startBtn').classList.add('btn-primary');
        }

        // é›¢é–‹æœƒè­°
        async function leaveMeeting() {
            try {
                await supabaseClient
                    .from('participants')
                    .delete()
                    .eq('meeting_id', MEETING_ID)
                    .eq('user_id', currentUser.id);

                if (participantsChannel) participantsChannel.unsubscribe();
                if (captionsChannel) captionsChannel.unsubscribe();

                // æ–·é–‹ PeerJS èªéŸ³
                if (peer) {
                    peerConnections.forEach(call => call.close());
                    peerConnections.clear();
                    peer.destroy();
                    peer = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                if (voiceChannel) {
                    voiceChannel.unsubscribe();
                    voiceChannel = null;
                }
                // ç§»é™¤æ‰€æœ‰é ç«¯éŸ³è¨Šå…ƒç´ 
                document.querySelectorAll('audio[id^="audio-"]').forEach(el => el.remove());

                console.log('âœ… å·²é›¢é–‹æœƒè­°');
            } catch (error) {
                console.error('é›¢é–‹æœƒè­°å¤±æ•—:', error);
            }
        }

        // ç¶å®šæŒ‰éˆ•äº‹ä»¶
        document.getElementById('startBtn').addEventListener('click', async () => {
            if (!isRecording) {
                const speakerOK = await initSpeakerDetection();
                if (speakerOK) {
                    // ä½¿ç”¨ Deepgram èªéŸ³è¾¨è­˜
                    const deepgramOK = await startDeepgramStream();
                    if (deepgramOK) {
                        isRecording = true;
                        document.getElementById('startBtn').textContent = 'åœæ­¢éŒ„éŸ³';
                        document.getElementById('startBtn').classList.remove('btn-primary');
                        document.getElementById('startBtn').classList.add('btn-danger');
                        console.log('ğŸ¤ é–‹å§‹éŒ„éŸ³ (Deepgram)');
                    }
                }

            } else {
                stopDeepgramStream();
                stopRecording();
                console.log('â¸ï¸ åœæ­¢éŒ„éŸ³');
            }
        });

        document.getElementById('leaveBtn').addEventListener('click', async () => {
            if (confirm('ç¢ºå®šè¦é›¢é–‹æœƒè­°å—ï¼Ÿ')) {
                stopDeepgramStream();
                stopRecording();
                await leaveMeeting();
                // å›åˆ°æˆ¿é–“åˆ—è¡¨ï¼Œä¸ç™»å‡º
                window.location.href = 'index.html';
            }
        });


        document.getElementById('languageSelect').addEventListener('change', (e) => {
            if (recognition) {
                const wasRecording = isRecording;
                if (wasRecording) recognition.stop();
                recognition.lang = e.target.value;
                if (wasRecording) setTimeout(() => recognition.start(), 100);
            }
        });

        document.getElementById('toggleCaptions').addEventListener('click', () => {
            const container = document.getElementById('captionContainer');
            const btn = document.getElementById('toggleCaptions');
            container.classList.toggle('expanded');
            btn.textContent = container.classList.contains('expanded') ? 'æ”¶åˆ â–¼' : 'å±•é–‹ â–²';
        });

        // é é¢é—œé–‰æ™‚é›¢é–‹æœƒè­°
        window.addEventListener('beforeunload', () => {
            leaveMeeting();
        });

        console.log('=== æœƒè­°å®¤åˆå§‹åŒ–å®Œæˆ ===');

        // ========== PeerJS èªéŸ³é€šè©± ==========
        async function initPeerVoice() {
            try {
                // å–å¾—éº¥å…‹é¢¨æ¬Šé™
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                console.log('âœ… å–å¾—éº¥å…‹é¢¨æ¬Šé™');

                // å»ºç«‹ PeerJS é€£æ¥ï¼ˆä½¿ç”¨å…¬å…±ä¼ºæœå™¨ï¼‰
                const peerId = `${MEETING_ID}-${currentUser.id.substring(0, 8)}`;
                peer = new Peer(peerId, {
                    debug: 1
                });

                peer.on('open', (id) => {
                    console.log('âœ… PeerJS é€£æ¥æˆåŠŸ, ID:', id);
                    // å»£æ’­è‡ªå·±çš„ peerId çµ¦å…¶ä»–äºº
                    broadcastPeerId(id);
                    // è¨‚é–±å…¶ä»–äººçš„ peerId
                    subscribeToVoice();
                });

                peer.on('call', (call) => {
                    console.log('ğŸ“ æ”¶åˆ°ä¾†é›»:', call.peer);
                    // è‡ªå‹•æ¥è½
                    call.answer(localStream);
                    handleCall(call);
                });

                peer.on('error', (err) => {
                    console.error('PeerJS éŒ¯èª¤:', err);
                });

                updateVoiceButtons();

            } catch (error) {
                console.error('PeerJS åˆå§‹åŒ–å¤±æ•—:', error);
                alert('ç„¡æ³•å–å¾—éº¥å…‹é¢¨æ¬Šé™');
            }
        }

        // è™•ç†é€šè©±é€£æ¥
        function handleCall(call) {
            call.on('stream', (remoteStream) => {
                console.log('ğŸµ æ”¶åˆ°é ç«¯éŸ³è¨Š:', call.peer);
                playRemoteAudio(remoteStream, call.peer);
            });

            call.on('close', () => {
                console.log('ğŸ“´ é€šè©±çµæŸ:', call.peer);
                removeRemoteAudio(call.peer);
                peerConnections.delete(call.peer);
            });

            peerConnections.set(call.peer, call);
        }

        // æ’­æ”¾é ç«¯éŸ³è¨Š
        function playRemoteAudio(stream, peerId) {
            let audio = document.getElementById(`audio-${peerId}`);
            if (!audio) {
                audio = document.createElement('audio');
                audio.id = `audio-${peerId}`;
                audio.autoplay = true;
                audio.playsInline = true;
                audio.style.display = 'none';
                document.body.appendChild(audio);
            }
            audio.srcObject = stream;
            audio.muted = !isSpeakerOn;

            // ç¢ºä¿æ’­æ”¾ï¼ˆè™•ç†ç€è¦½å™¨è‡ªå‹•æ’­æ”¾æ”¿ç­–ï¼‰
            audio.play().then(() => {
                console.log('ğŸ”Š éŸ³è¨Šæ’­æ”¾æˆåŠŸ:', peerId);
            }).catch(err => {
                console.error('âŒ éŸ³è¨Šæ’­æ”¾å¤±æ•—:', err);
                // å¦‚æœè‡ªå‹•æ’­æ”¾è¢«é˜»æ“‹ï¼Œåœ¨ä½¿ç”¨è€…äº’å‹•æ™‚é‡è©¦
                document.addEventListener('click', () => {
                    audio.play().catch(e => console.error('é‡è©¦æ’­æ”¾å¤±æ•—:', e));
                }, { once: true });
            });
        }

        // ç§»é™¤é ç«¯éŸ³è¨Š
        function removeRemoteAudio(peerId) {
            const audio = document.getElementById(`audio-${peerId}`);
            if (audio) audio.remove();
        }

        // å»£æ’­è‡ªå·±çš„ peerId
        async function broadcastPeerId(peerId) {
            voiceChannel = supabaseClient.channel(`voice-${MEETING_ID}`);

            voiceChannel.on('broadcast', { event: 'peer-join' }, async (payload) => {
                const remotePeerId = payload.payload.peerId;
                if (remotePeerId !== peerId && !peerConnections.has(remotePeerId)) {
                    console.log('ğŸ“ æ’¥æ‰“çµ¦:', remotePeerId);
                    const call = peer.call(remotePeerId, localStream);
                    handleCall(call);
                }
            });

            await voiceChannel.subscribe();

            // å»£æ’­è‡ªå·±åŠ å…¥
            voiceChannel.send({
                type: 'broadcast',
                event: 'peer-join',
                payload: { peerId }
            });
        }

        // è¨‚é–±èªéŸ³é »é“
        function subscribeToVoice() {
            // å·²åœ¨ broadcastPeerId ä¸­è™•ç†
        }

        function updateVoiceButtons() {
            const micBtn = document.getElementById('micBtn');
            const speakerBtn = document.getElementById('speakerBtn');

            micBtn.textContent = isMicOn ? 'ğŸ™ï¸' : 'ğŸ”‡';
            micBtn.style.opacity = isMicOn ? '1' : '0.5';

            speakerBtn.textContent = isSpeakerOn ? 'ğŸ”Š' : 'ğŸ”ˆ';
            speakerBtn.style.opacity = isSpeakerOn ? '1' : '0.5';
        }

        // éº¥å…‹é¢¨é–‹é—œ
        document.getElementById('micBtn').addEventListener('click', () => {
            if (!localStream) {
                alert('èªéŸ³é€šè©±å°šæœªé€£æ¥');
                return;
            }
            isMicOn = !isMicOn;
            localStream.getAudioTracks().forEach(track => track.enabled = isMicOn);
            updateVoiceButtons();
            console.log('éº¥å…‹é¢¨:', isMicOn ? 'é–‹å•Ÿ' : 'é—œé–‰');
        });

        // å–‡å­é–‹é—œ
        document.getElementById('speakerBtn').addEventListener('click', () => {
            isSpeakerOn = !isSpeakerOn;
            // æ§åˆ¶æ‰€æœ‰é ç«¯éŸ³è¨Šçš„éœéŸ³
            document.querySelectorAll('audio[id^="audio-"]').forEach(audio => {
                audio.muted = !isSpeakerOn;
            });
            updateVoiceButtons();
            console.log('å–‡å­:', isSpeakerOn ? 'é–‹å•Ÿ' : 'é—œé–‰');
        });

        // é€²å…¥æœƒè­°å®¤å¾Œè‡ªå‹•é€£æ¥èªéŸ³
        setTimeout(() => {
            if (currentUser) {
                initPeerVoice();
            }
        }, 2000);
    </script>
</body>

</html>